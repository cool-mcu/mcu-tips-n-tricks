Disassembly Listing for cpu-arith-benchmark
Generated From:
/Users/Dennis/Documents/design.projects/thinkific.cool-mcu.com/github/mcu-tips-n-tricks/cpu-arith-benchmark/cpu-arith-benchmark.X/dist/PIC16LF15356_BB/production/cpu-arith-benchmark.X.production.elf
Sep 7, 2020 12:10:09 PM

---  /tmp/xcF4wuuH6.s  ----------------------------------------------------------------------------------
0BDA  00FE     MOVWF 0x7E
0BDB  0012     MOVIW FSR0++
0BDC  001E     MOVWI FSR1++
0BDD  0BFE     DECFSZ 0x7E, F
0BDE  2BDB     GOTO 0x3DB
0BDF  3400     RETLW 0x0
07E1  30E7     MOVLW 0xE7
07E2  0084     MOVWF FSR0
07E3  308B     MOVLW 0x8B
07E4  0085     MOVWF FSR0H
07E5  30E3     MOVLW 0xE3
07E6  0086     MOVWF FSR1
07E7  3000     MOVLW 0x0
07E8  0087     MOVWF FSR1H
07E9  3007     MOVLW 0x7
07EA  318B     MOVLP 0xB
0BD4  0064     CLRWDT
0BD5  0180     CLRF INDF0
0BD6  3101     ADDFSR 0, 1
0BD7  0B89     DECFSZ WREG, F
0BD8  2BD5     GOTO 0x3D5
0BD9  3400     RETLW 0x0
07ED  30A0     MOVLW 0xA0
07EE  0084     MOVWF FSR0
07EF  3000     MOVLW 0x0
07F0  0085     MOVWF FSR0H
07F1  3043     MOVLW 0x43
07F2  318B     MOVLP 0xB
07F5  3020     MOVLW 0x20
07F6  0084     MOVWF FSR0
07F7  3001     MOVLW 0x1
07F8  0085     MOVWF FSR0H
07F9  3020     MOVLW 0x20
07FA  318B     MOVLP 0xB
07FD  0140     MOVLB 0x0
07FE  3183     MOVLP 0x3
---  /Users/Dennis/Documents/design.projects/thinkific.cool-mcu.com/github/mcu-tips-n-tricks/cpu-arith-benchmark/cpu-arith-benchmark.X/main.c
1:             /*******************************************************************************
2:              * Copyright (c) 2020 dBm Signal Dynamics Inc.
3:              * 
4:              * File:        main.c
5:              * Project:     cpu-arith-benchmark
6:              * Compiler:    XC8 v2.20, XC16 v1.60, XC32 v2.41
7:              * Course:      MCU Tips n' Tricks
8:              * URL:         https://www.cool-mcu.com/courses/mcu-tips-n-tricks
9:              * Chapter:     Hardware Tips n Tricks
10:             * Lesson:      Selecting a Microcontroller
11:             * 
12:             * Project uses MCU 16-bit timer resource to compute then print out
13:             * cycle-counts for several arithmetic functions/operations on PIC16F1, PIC24F,
14:             * and PIC32MZ-based MCUs
15:             * 
16:             * SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
17:             * EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
18:             * MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
19:             * IN NO EVENT SHALL DBM SIGNAL DYNAMICS OR ITS LICENSORS BE LIABLE OR OBLIGATED
20:             * UNDER CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY,
21:             * OR OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
22:             * INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
23:             * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
24:             * SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
25:             * (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
26:            *******************************************************************************/
27:            #include <xc.h>
28:            #include <stdint.h>
29:            #include <stdio.h>
30:            #include "configBits.h"     // Hardware Configuration bit settings
31:            
32:            #if defined(PIC16LF15356_BB)
33:            #define ELAPSED_TICKS_ADJUSTMENT 9
34:            #define NoOP() NOP()
35:            #elif defined(PIC16LF18456_BLE)
36:            #define ELAPSED_TICKS_ADJUSTMENT 8
37:            #define NoOP() NOP()
38:            #elif defined(PIC24FJ256GA702_BB)
39:            #include <libpic30.h>                   // Added for printf() --> UART2 redirect support
40:            #define ELAPSED_TICKS_ADJUSTMENT 9      // Timer Tick Adjustment for reading the timer register
41:            #define NoOP() Nop()
42:            #elif defined(PIC32MX170F256B_BB)
43:            #include <cp0defs.h>                    // CP0 access macros for PIC32M devices
44:            #define ELAPSED_TICKS_ADJUSTMENT 12     // Timer Tick Adjustment for reading the timer register
45:            #define NoOP() Nop()
46:            #elif defined(PIC32MZ1024EFH064_MINI32_BB)
47:            #include <cp0defs.h>                    // CP0 access macros for PIC32M devices
48:            #define ELAPSED_TICKS_ADJUSTMENT 12     // Timer Tick Adjustment for reading the timer register
49:            #define NoOP() Nop()
50:            #endif
51:            
52:            // Global Variables
53:            
54:            const char Project[] = "cpu-arith-benchmark";
55:            const char Version[] = "00.01";
56:            const char CompileDate[] = __DATE__;
57:            const char CompileTime[] = __TIME__;
58:            
59:            int8_t a, b, c;
60:            int16_t g;
61:            int32_t d, e, f;
62:            int64_t h;
63:            float i, j, k;
64:            double l, m, n;
65:            
66:            typedef union{
67:                uint16_t Full;      // full 16-bit timer value
68:                struct{
69:                    uint8_t Low;    // low 8-bit value
70:                    uint8_t High;   // high 8-bit value      
71:                };
72:            }elapsedTime;           // 16-bit Stopwatch Counter Type
73:            
74:            
75:            elapsedTime elapsedTicks_sum8, elapsedTicks_sum32, elapsedTicks_mul8, elapsedTicks_mul32, elapsedTicks_fp32, elapsedTicks_fp64;
76:            
77:            
78:            // Local Function Prototypes
79:            int8_t sum8(int8_t a, int8_t b);            // 8-bit integer addition function
80:            int32_t sum32(int32_t a, int32_t b);        // 32-bit integer addition function
81:            int16_t mul8(int8_t a, int8_t b);           // 8x8 integer multiplication function
82:            int64_t mul32(int32_t a, int32_t b);        // 32x32 integer multiplication function
83:            
84:            void Initiallize(void);                     // 1-time System Initialization
85:            void SetPerformanceMode(void);              // Configure Clocks, Interrupts, Cache, Pre-fetch for desired performance
86:            void PinConfig(void);                       // Configure I/O pins
87:            void UartConfig(void);                      // Configure UART for printf() statement
88:            void StopwatchConfig(void);                 // Configure the 16-bit timer resource for the stopwatch function
89:            void StopwatchRestart(void);                // Clear the 16-bit counter and restart.
90:            uint16_t StopwatchRead(void);               // Stop the 16-bit counter and read the elapsed time
91:            
92:            int main(void) {
93:                
94:                Initiallize();
03B8  318D     MOVLP 0xD
03B9  259E     CALL 0x59E
03BA  3183     MOVLP 0x3
95:              
96:                // Operands for sum8() and mul8()
97:                a = 2;
03BB  3002     MOVLW 0x2
03BC  0141     MOVLB 0x1
03BD  00EC     MOVWF __pcstackBANK1
03BE  086C     MOVF __pcstackBANK1, W
03BF  00EB     MOVWF a
98:                b = 3;
03C0  3003     MOVLW 0x3
03C1  00EC     MOVWF __pcstackBANK1
03C2  086C     MOVF __pcstackBANK1, W
03C3  00EA     MOVWF b
99:                
100:               // sum8() benchmark
101:               StopwatchRestart();
03C4  318B     MOVLP 0xB
03C5  23CF     CALL 0x3CF
03C6  3183     MOVLP 0x3
102:               NoOP();              // NoOP() used with hardware debugger stopwatch function
03C7  0000     NOP
103:               c = sum8(a, b);
03C8  3003     MOVLW 0x3
03C9  0141     MOVLB 0x1
03CA  00EC     MOVWF __pcstackBANK1
03CB  086C     MOVF __pcstackBANK1, W
03CC  00F0     MOVWF 0xF0
03CD  3002     MOVLW 0x2
03CE  318B     MOVLP 0xB
03CF  23CB     CALL 0x3CB
03D0  3183     MOVLP 0x3
03D1  0141     MOVLB 0x1
03D2  00ED     MOVWF 0xED
03D3  086D     MOVF 0xED, W
03D4  00E2     MOVWF c
104:               NoOP();              // NoOP() used with hardware debugger stopwatch function
03D5  0000     NOP
105:               elapsedTicks_sum8.Full = StopwatchRead() - ELAPSED_TICKS_ADJUSTMENT;
03D6  318B     MOVLP 0xB
03D7  23F7     CALL 0x3F7
03D8  3183     MOVLP 0x3
03D9  0870     MOVF 0xF0, W
03DA  3EF7     ADDLW 0xF7
03DB  0141     MOVLB 0x1
03DC  00DE     MOVWF elapsedTicks_sum8
03DD  30FF     MOVLW 0xFF
03DE  3D71     ADDWFC 0xF1, W
03DF  00DF     MOVWF 0xDF
106:               
107:               // mul8() benchmark
108:               StopwatchRestart();
03E0  318B     MOVLP 0xB
03E1  23CF     CALL 0x3CF
03E2  3183     MOVLP 0x3
109:               NoOP();
03E3  0000     NOP
110:               g = mul8(a, b);
03E4  3003     MOVLW 0x3
03E5  0141     MOVLB 0x1
03E6  00EC     MOVWF __pcstackBANK1
03E7  086C     MOVF __pcstackBANK1, W
03E8  00F6     MOVWF 0xF6
03E9  3002     MOVLW 0x2
03EA  318C     MOVLP 0xC
03EB  242B     CALL 0x42B
03EC  3183     MOVLP 0x3
03ED  0877     MOVF 0xF7, W
03EE  0141     MOVLB 0x1
03EF  00E1     MOVWF 0xE1
03F0  0876     MOVF 0xF6, W
03F1  00E0     MOVWF g
111:               NoOP();
03F2  0000     NOP
112:               elapsedTicks_mul8.Full = StopwatchRead() - ELAPSED_TICKS_ADJUSTMENT;
03F3  318B     MOVLP 0xB
03F4  23F7     CALL 0x3F7
03F5  3183     MOVLP 0x3
03F6  0870     MOVF 0xF0, W
03F7  3EF7     ADDLW 0xF7
03F8  0141     MOVLB 0x1
03F9  00DA     MOVWF elapsedTicks_mul8
03FA  30FF     MOVLW 0xFF
03FB  3D71     ADDWFC 0xF1, W
03FC  00DB     MOVWF 0xDB
113:               
114:               // Operands for sum32() and mul32()
115:               d = 4;
03FD  3000     MOVLW 0x0
03FE  00CB     MOVWF 0xCB
03FF  3000     MOVLW 0x0
0400  00CA     MOVWF 0xCA
0401  3000     MOVLW 0x0
0402  00C9     MOVWF 0xC9
0403  3004     MOVLW 0x4
0404  00C8     MOVWF d
116:               e = 5;
0405  3000     MOVLW 0x0
0406  00C7     MOVWF 0xC7
0407  3000     MOVLW 0x0
0408  00C6     MOVWF 0xC6
0409  3000     MOVLW 0x0
040A  00C5     MOVWF 0xC5
040B  3005     MOVLW 0x5
040C  00C4     MOVWF e
117:               
118:               // sum32() benchmark
119:               StopwatchRestart();
040D  318B     MOVLP 0xB
040E  23CF     CALL 0x3CF
040F  3183     MOVLP 0x3
120:               NoOP();
0410  0000     NOP
121:               f = sum32(d, e);
0411  3000     MOVLW 0x0
0412  00F3     MOVWF 0xF3
0413  3000     MOVLW 0x0
0414  00F2     MOVWF 0xF2
0415  3000     MOVLW 0x0
0416  00F1     MOVWF 0xF1
0417  3004     MOVLW 0x4
0418  00F0     MOVWF 0xF0
0419  3000     MOVLW 0x0
041A  00F7     MOVWF 0xF7
041B  3000     MOVLW 0x0
041C  00F6     MOVWF 0xF6
041D  3000     MOVLW 0x0
041E  00F5     MOVWF 0xF5
041F  3005     MOVLW 0x5
0420  00F4     MOVWF 0xF4
0421  318C     MOVLP 0xC
0422  243E     CALL 0x43E
0423  3183     MOVLP 0x3
0424  0873     MOVF 0xF3, W
0425  0141     MOVLB 0x1
0426  00C3     MOVWF 0xC3
0427  0872     MOVF 0xF2, W
0428  00C2     MOVWF 0xC2
0429  0871     MOVF 0xF1, W
042A  00C1     MOVWF 0xC1
042B  0870     MOVF 0xF0, W
042C  00C0     MOVWF f
122:               NoOP();
042D  0000     NOP
123:               elapsedTicks_sum32.Full = StopwatchRead() - ELAPSED_TICKS_ADJUSTMENT;
042E  318B     MOVLP 0xB
042F  23F7     CALL 0x3F7
0430  3183     MOVLP 0x3
0431  0870     MOVF 0xF0, W
0432  3EF7     ADDLW 0xF7
0433  0141     MOVLB 0x1
0434  00DC     MOVWF elapsedTicks_sum32
0435  30FF     MOVLW 0xFF
0436  3D71     ADDWFC 0xF1, W
0437  00DD     MOVWF 0xDD
124:               
125:               // mul32() benchmark
126:               StopwatchRestart();
0438  318B     MOVLP 0xB
0439  23CF     CALL 0x3CF
043A  3183     MOVLP 0x3
127:               NoOP();
043B  0000     NOP
128:               h = mul32(d, e);
043C  3000     MOVLW 0x0
043D  0140     MOVLB 0x0
043E  00A3     MOVWF s
043F  3000     MOVLW 0x0
0440  00A2     MOVWF 0x22
0441  3000     MOVLW 0x0
0442  00A1     MOVWF i
0443  3004     MOVLW 0x4
0444  00A0     MOVWF __pcstackBANK0
0445  3000     MOVLW 0x0
0446  00A7     MOVWF i
0447  3000     MOVLW 0x0
0448  00A6     MOVWF 0x26
0449  3000     MOVLW 0x0
044A  00A5     MOVWF p
044B  3005     MOVLW 0x5
044C  00A4     MOVWF b
044D  318C     MOVLP 0xC
044E  24E0     CALL 0x4E0
044F  3183     MOVLP 0x3
0450  0140     MOVLB 0x0
0451  0820     MOVF __pcstackBANK0, W
0452  0141     MOVLB 0x1
0453  00A0     MOVWF h
0454  0140     MOVLB 0x0
0455  0821     MOVF i, W
0456  0141     MOVLB 0x1
0457  00A1     MOVWF 0xA1
0458  0140     MOVLB 0x0
0459  0822     MOVF 0x22, W
045A  0141     MOVLB 0x1
045B  00A2     MOVWF 0xA2
045C  0140     MOVLB 0x0
045D  0823     MOVF s, W
045E  0141     MOVLB 0x1
045F  00A3     MOVWF 0xA3
0460  0140     MOVLB 0x0
0461  0824     MOVF b, W
0462  0141     MOVLB 0x1
0463  00A4     MOVWF 0xA4
0464  0140     MOVLB 0x0
0465  0825     MOVF p, W
0466  0141     MOVLB 0x1
0467  00A5     MOVWF 0xA5
0468  0140     MOVLB 0x0
0469  0826     MOVF 0x26, W
046A  0141     MOVLB 0x1
046B  00A6     MOVWF 0xA6
046C  0140     MOVLB 0x0
046D  0827     MOVF i, W
046E  0141     MOVLB 0x1
046F  00A7     MOVWF 0xA7
129:               NoOP();
0470  0000     NOP
130:               elapsedTicks_mul32.Full = StopwatchRead() - ELAPSED_TICKS_ADJUSTMENT;
0471  318B     MOVLP 0xB
0472  23F7     CALL 0x3F7
0473  3183     MOVLP 0x3
0474  0870     MOVF 0xF0, W
0475  3EF7     ADDLW 0xF7
0476  0141     MOVLB 0x1
0477  00D8     MOVWF elapsedTicks_mul32
0478  30FF     MOVLW 0xFF
0479  3D71     ADDWFC 0xF1, W
047A  00D9     MOVWF 0xD9
131:               
132:               // Operands for single-precision multiply
133:               i = 6.0;
047B  3040     MOVLW 0x40
047C  00BF     MOVWF 0xBF
047D  30C0     MOVLW 0xC0
047E  00BE     MOVWF 0xBE
047F  3000     MOVLW 0x0
0480  00BD     MOVWF 0xBD
0481  3000     MOVLW 0x0
0482  00BC     MOVWF i
134:               j = -7.125;
0483  30C0     MOVLW 0xC0
0484  00BB     MOVWF 0xBB
0485  30E4     MOVLW 0xE4
0486  00BA     MOVWF 0xBA
0487  3000     MOVLW 0x0
0488  00B9     MOVWF 0xB9
0489  3000     MOVLW 0x0
048A  00B8     MOVWF j
135:               
136:               // Single precision (32-bit) floating point multiply benchmark
137:               StopwatchRestart();
048B  318B     MOVLP 0xB
048C  23CF     CALL 0x3CF
048D  3183     MOVLP 0x3
138:               NoOP();
048E  0000     NOP
139:               k = i*j;
048F  0141     MOVLB 0x1
0490  083B     MOVF 0xBB, W
0491  0140     MOVLB 0x0
0492  00A3     MOVWF s
0493  0141     MOVLB 0x1
0494  083A     MOVF 0xBA, W
0495  0140     MOVLB 0x0
0496  00A2     MOVWF 0x22
0497  0141     MOVLB 0x1
0498  0839     MOVF 0xB9, W
0499  0140     MOVLB 0x0
049A  00A1     MOVWF i
049B  0141     MOVLB 0x1
049C  0838     MOVF j, W
049D  0140     MOVLB 0x0
049E  00A0     MOVWF __pcstackBANK0
049F  0141     MOVLB 0x1
04A0  083F     MOVF 0xBF, W
04A1  0140     MOVLB 0x0
04A2  00A7     MOVWF i
04A3  0141     MOVLB 0x1
04A4  083E     MOVF 0xBE, W
04A5  0140     MOVLB 0x0
04A6  00A6     MOVWF 0x26
04A7  0141     MOVLB 0x1
04A8  083D     MOVF 0xBD, W
04A9  0140     MOVLB 0x0
04AA  00A5     MOVWF p
04AB  0141     MOVLB 0x1
04AC  083C     MOVF i, W
04AD  0140     MOVLB 0x0
04AE  00A4     MOVWF b
04AF  3185     MOVLP 0x5
04B0  258A     CALL 0x58A
04B1  3183     MOVLP 0x3
04B2  0140     MOVLB 0x0
04B3  0823     MOVF s, W
04B4  0141     MOVLB 0x1
04B5  00B7     MOVWF 0xB7
04B6  0140     MOVLB 0x0
04B7  0822     MOVF 0x22, W
04B8  0141     MOVLB 0x1
04B9  00B6     MOVWF 0xB6
04BA  0140     MOVLB 0x0
04BB  0821     MOVF i, W
04BC  0141     MOVLB 0x1
04BD  00B5     MOVWF 0xB5
04BE  0140     MOVLB 0x0
04BF  0820     MOVF __pcstackBANK0, W
04C0  0141     MOVLB 0x1
04C1  00B4     MOVWF k
140:               NoOP();
04C2  0000     NOP
141:               elapsedTicks_fp32.Full = StopwatchRead() - ELAPSED_TICKS_ADJUSTMENT;
04C3  318B     MOVLP 0xB
04C4  23F7     CALL 0x3F7
04C5  3183     MOVLP 0x3
04C6  0870     MOVF 0xF0, W
04C7  3EF7     ADDLW 0xF7
04C8  0141     MOVLB 0x1
04C9  00D6     MOVWF elapsedTicks_fp32
04CA  30FF     MOVLW 0xFF
04CB  3D71     ADDWFC 0xF1, W
04CC  00D7     MOVWF 0xD7
142:               
143:               // Operands for double-precision multiply
144:               l = 6.8;
04CD  3040     MOVLW 0x40
04CE  00B3     MOVWF 0xB3
04CF  30D9     MOVLW 0xD9
04D0  00B2     MOVWF 0xB2
04D1  3099     MOVLW 0x99
04D2  00B1     MOVWF 0xB1
04D3  309A     MOVLW 0x9A
04D4  00B0     MOVWF l
145:               m = -7.125;
04D5  30C0     MOVLW 0xC0
04D6  00AF     MOVWF 0xAF
04D7  30E4     MOVLW 0xE4
04D8  00AE     MOVWF 0xAE
04D9  3000     MOVLW 0x0
04DA  00AD     MOVWF 0xAD
04DB  3000     MOVLW 0x0
04DC  00AC     MOVWF m
146:               
147:               // Double precision (64-bit) floating point multiply benchmark 
148:               StopwatchRestart();
04DD  318B     MOVLP 0xB
04DE  23CF     CALL 0x3CF
04DF  3183     MOVLP 0x3
149:               NoOP();
04E0  0000     NOP
150:               n = l*m;
04E1  0141     MOVLB 0x1
04E2  082F     MOVF 0xAF, W
04E3  0140     MOVLB 0x0
04E4  00A3     MOVWF s
04E5  0141     MOVLB 0x1
04E6  082E     MOVF 0xAE, W
04E7  0140     MOVLB 0x0
04E8  00A2     MOVWF 0x22
04E9  0141     MOVLB 0x1
04EA  082D     MOVF 0xAD, W
04EB  0140     MOVLB 0x0
04EC  00A1     MOVWF i
04ED  0141     MOVLB 0x1
04EE  082C     MOVF m, W
04EF  0140     MOVLB 0x0
04F0  00A0     MOVWF __pcstackBANK0
04F1  0141     MOVLB 0x1
04F2  0833     MOVF 0xB3, W
04F3  0140     MOVLB 0x0
04F4  00A7     MOVWF i
04F5  0141     MOVLB 0x1
04F6  0832     MOVF 0xB2, W
04F7  0140     MOVLB 0x0
04F8  00A6     MOVWF 0x26
04F9  0141     MOVLB 0x1
04FA  0831     MOVF 0xB1, W
04FB  0140     MOVLB 0x0
04FC  00A5     MOVWF p
04FD  0141     MOVLB 0x1
04FE  0830     MOVF l, W
04FF  0140     MOVLB 0x0
0500  00A4     MOVWF b
0501  3185     MOVLP 0x5
0502  258A     CALL 0x58A
0503  3183     MOVLP 0x3
0504  0140     MOVLB 0x0
0505  0823     MOVF s, W
0506  0141     MOVLB 0x1
0507  00AB     MOVWF 0xAB
0508  0140     MOVLB 0x0
0509  0822     MOVF 0x22, W
050A  0141     MOVLB 0x1
050B  00AA     MOVWF 0xAA
050C  0140     MOVLB 0x0
050D  0821     MOVF i, W
050E  0141     MOVLB 0x1
050F  00A9     MOVWF 0xA9
0510  0140     MOVLB 0x0
0511  0820     MOVF __pcstackBANK0, W
0512  0141     MOVLB 0x1
0513  00A8     MOVWF n
151:               NoOP();
0514  0000     NOP
152:               elapsedTicks_fp64.Full = StopwatchRead() - ELAPSED_TICKS_ADJUSTMENT;
0515  318B     MOVLP 0xB
0516  23F7     CALL 0x3F7
0517  3183     MOVLP 0x3
0518  0870     MOVF 0xF0, W
0519  3EF7     ADDLW 0xF7
051A  0141     MOVLB 0x1
051B  00D4     MOVWF elapsedTicks_fp64
051C  30FF     MOVLW 0xFF
051D  3D71     ADDWFC 0xF1, W
051E  00D5     MOVWF 0xD5
153:               
154:               // print the results
155:           #if defined(PIC32MZ1024EFH064_MINI32_BB)
156:               printf("Configuration: PIC32MZ1024EFH064_MINI32 on a Breadboard @ 8 MIPs\r\n");
157:           #elif defined(PIC32MX170F256B_BB)
158:               printf("Configuration: PIC32MX170F256B on a Breadboard @ 8 MIPs\r\n");
159:           #elif defined(PIC24FJ256GA702_BB)
160:               printf("Configuration: PIC24FJ256GA702 on a Breadboard @ 8 MIPs\r\n");
161:           #elif defined(PIC16LF15356_BB)
162:               printf("Configuration: PIC16LF15356 on a Breadboard @ 8 MIPs\r\n");
051F  3000     MOVLW 0x0
0520  0140     MOVLB 0x0
0521  00E8     MOVWF fmt
0522  3090     MOVLW 0x90
0523  00E9     MOVWF 0x69
0524  318C     MOVLP 0xC
0525  2406     CALL 0x406
0526  3183     MOVLP 0x3
163:           #elif defined(PIC16LF18456_BLE)
164:               printf("Configuration: PIC16LF18456 on PIC-BLE Board @ 8 MIPs\r\n");
165:           #endif
166:               printf("sum8():  %d cycles\r\n", elapsedTicks_sum8.Full);
0527  309A     MOVLW 0x9A
0528  0140     MOVLB 0x0
0529  00E8     MOVWF fmt
052A  3090     MOVLW 0x90
052B  00E9     MOVWF 0x69
052C  0141     MOVLB 0x1
052D  085F     MOVF 0xDF, W
052E  0140     MOVLB 0x0
052F  00EB     MOVWF 0x6B
0530  0141     MOVLB 0x1
0531  085E     MOVF elapsedTicks_sum8, W
0532  0140     MOVLB 0x0
0533  00EA     MOVWF 0x6A
0534  318C     MOVLP 0xC
0535  2406     CALL 0x406
0536  3183     MOVLP 0x3
167:               printf("sum32(): %d cycles\r\n", elapsedTicks_sum32.Full);
0537  30C4     MOVLW 0xC4
0538  0140     MOVLB 0x0
0539  00E8     MOVWF fmt
053A  3090     MOVLW 0x90
053B  00E9     MOVWF 0x69
053C  0141     MOVLB 0x1
053D  085D     MOVF 0xDD, W
053E  0140     MOVLB 0x0
053F  00EB     MOVWF 0x6B
0540  0141     MOVLB 0x1
0541  085C     MOVF elapsedTicks_sum32, W
0542  0140     MOVLB 0x0
0543  00EA     MOVWF 0x6A
0544  318C     MOVLP 0xC
0545  2406     CALL 0x406
0546  3183     MOVLP 0x3
168:               printf("mul8():  %d cycles\r\n", elapsedTicks_mul8.Full);
0547  3085     MOVLW 0x85
0548  0140     MOVLB 0x0
0549  00E8     MOVWF fmt
054A  3090     MOVLW 0x90
054B  00E9     MOVWF 0x69
054C  0141     MOVLB 0x1
054D  085B     MOVF 0xDB, W
054E  0140     MOVLB 0x0
054F  00EB     MOVWF 0x6B
0550  0141     MOVLB 0x1
0551  085A     MOVF elapsedTicks_mul8, W
0552  0140     MOVLB 0x0
0553  00EA     MOVWF 0x6A
0554  318C     MOVLP 0xC
0555  2406     CALL 0x406
0556  3183     MOVLP 0x3
169:               printf("mul32(): %d cycles\r\n", elapsedTicks_mul32.Full);
0557  30AF     MOVLW 0xAF
0558  0140     MOVLB 0x0
0559  00E8     MOVWF fmt
055A  3090     MOVLW 0x90
055B  00E9     MOVWF 0x69
055C  0141     MOVLB 0x1
055D  0859     MOVF 0xD9, W
055E  0140     MOVLB 0x0
055F  00EB     MOVWF 0x6B
0560  0141     MOVLB 0x1
0561  0858     MOVF elapsedTicks_mul32, W
0562  0140     MOVLB 0x0
0563  00EA     MOVWF 0x6A
0564  318C     MOVLP 0xC
0565  2406     CALL 0x406
0566  3183     MOVLP 0x3
170:               printf("float32mul: %d cycles\r\n", elapsedTicks_fp32.Full);
0567  306D     MOVLW 0x6D
0568  0140     MOVLB 0x0
0569  00E8     MOVWF fmt
056A  3090     MOVLW 0x90
056B  00E9     MOVWF 0x69
056C  0141     MOVLB 0x1
056D  0857     MOVF 0xD7, W
056E  0140     MOVLB 0x0
056F  00EB     MOVWF 0x6B
0570  0141     MOVLB 0x1
0571  0856     MOVF elapsedTicks_fp32, W
0572  0140     MOVLB 0x0
0573  00EA     MOVWF 0x6A
0574  318C     MOVLP 0xC
0575  2406     CALL 0x406
0576  3183     MOVLP 0x3
171:               printf("float64mul: %d cycles\r\n\r\n", elapsedTicks_fp64.Full);
0577  3053     MOVLW 0x53
0578  0140     MOVLB 0x0
0579  00E8     MOVWF fmt
057A  3090     MOVLW 0x90
057B  00E9     MOVWF 0x69
057C  0141     MOVLB 0x1
057D  0855     MOVF 0xD5, W
057E  0140     MOVLB 0x0
057F  00EB     MOVWF 0x6B
0580  0141     MOVLB 0x1
0581  0854     MOVF elapsedTicks_fp64, W
0582  0140     MOVLB 0x0
0583  00EA     MOVWF 0x6A
0584  318C     MOVLP 0xC
0585  2406     CALL 0x406
0586  3183     MOVLP 0x3
172:               
173:               while(1);
0587  2D87     GOTO 0x587
0588  3180     MOVLP 0x0
0589  2802     GOTO 0x2
174:             
175:           }
176:           
177:           void Initiallize(void){
178:               
179:               // Configure Clocks, Interrupts, Cache, Pre-fetch for desired performance
180:               SetPerformanceMode();       
0D9E  3180     MOVLP 0x0
0D9F  2005     CALL 0x5
0DA0  318D     MOVLP 0xD
181:               
182:               // Configure Pins for all I/O in this application
183:               PinConfig();
0DA1  318C     MOVLP 0xC
0DA2  2453     CALL 0x453
0DA3  318D     MOVLP 0xD
184:               
185:               // Configure UART resource for printf() statement
186:               UartConfig();
0DA4  318C     MOVLP 0xC
0DA5  2418     CALL 0x418
0DA6  318D     MOVLP 0xD
187:               
188:               printf("Course: MCU Tips-n-Tricks\r\n");
0DA7  3037     MOVLW 0x37
0DA8  0140     MOVLB 0x0
0DA9  00E8     MOVWF fmt
0DAA  3090     MOVLW 0x90
0DAB  00E9     MOVWF 0x69
0DAC  318C     MOVLP 0xC
0DAD  2406     CALL 0x406
0DAE  318D     MOVLP 0xD
189:               printf("Project: %s\r\n", Project);
0DAF  301F     MOVLW 0x1F
0DB0  0140     MOVLB 0x0
0DB1  00E8     MOVWF fmt
0DB2  3091     MOVLW 0x91
0DB3  00E9     MOVWF 0x69
0DB4  30D9     MOVLW 0xD9
0DB5  00EA     MOVWF 0x6A
0DB6  3090     MOVLW 0x90
0DB7  00EB     MOVWF 0x6B
0DB8  318C     MOVLP 0xC
0DB9  2406     CALL 0x406
0DBA  318D     MOVLP 0xD
190:               printf("Version: %s\r\n", Version);
0DBB  3011     MOVLW 0x11
0DBC  0140     MOVLB 0x0
0DBD  00E8     MOVWF fmt
0DBE  3091     MOVLW 0x91
0DBF  00E9     MOVWF 0x69
0DC0  3042     MOVLW 0x42
0DC1  00EA     MOVWF 0x6A
0DC2  3091     MOVLW 0x91
0DC3  00EB     MOVWF 0x6B
0DC4  318C     MOVLP 0xC
0DC5  2406     CALL 0x406
0DC6  318D     MOVLP 0xD
191:               printf("Build date: %s\r\n", CompileDate);
0DC7  3000     MOVLW 0x0
0DC8  0140     MOVLB 0x0
0DC9  00E8     MOVWF fmt
0DCA  3091     MOVLW 0x91
0DCB  00E9     MOVWF 0x69
0DCC  302D     MOVLW 0x2D
0DCD  00EA     MOVWF 0x6A
0DCE  3091     MOVLW 0x91
0DCF  00EB     MOVWF 0x6B
0DD0  318C     MOVLP 0xC
0DD1  2406     CALL 0x406
0DD2  318D     MOVLP 0xD
192:               printf("Build time: %s\r\n\r\n", CompileTime);
0DD3  30ED     MOVLW 0xED
0DD4  0140     MOVLB 0x0
0DD5  00E8     MOVWF fmt
0DD6  3090     MOVLW 0x90
0DD7  00E9     MOVWF 0x69
0DD8  3039     MOVLW 0x39
0DD9  00EA     MOVWF 0x6A
0DDA  3091     MOVLW 0x91
0DDB  00EB     MOVWF 0x6B
0DDC  318C     MOVLP 0xC
0DDD  2406     CALL 0x406
0DDE  318D     MOVLP 0xD
193:               
194:               // Configure/Start timer resource for benchmark time measurement
195:               StopwatchConfig();          
0DDF  318B     MOVLP 0xB
0DE0  23E0     CALL 0x3E0
0DE1  318D     MOVLP 0xD
196:               
197:           }
0DE2  0008     RETURN
198:           
199:           void SetPerformanceMode(void) {
200:               
201:               // At this point, the CPU is operating using the default oscillator and
202:               // clocking options defined by the hardware configuration bits.
203:               
204:               // Add any code below to adjust clocks and any other configuration for
205:               // desired performance before running your main code loop.
206:               
207:           #if defined(PIC32MZ1024EFH064_MINI32_BB)
208:               
209:               // At this point, the Hardware Clock Initialization is Complete
210:           	// The Internal Fast RC Oscillator (8 MHz) provides the clock source
211:           	// Instruction Clock, PBCLK7 (SYSCLK) set to 8 MHz
212:               // Peripheral Bus Clocks divisors set to defaults (divide by 2))
213:               // Flash memory predictive prefetch disabled
214:               // Cache memory is enabled (per compiler default XC32 startup setting)
215:               // Interrupt controller is in single vector mode (per compiler default XC32 startup setting)
216:               // Interrupts are disabled (per compiler default XC32 startup setting)
217:               
218:               // Set the desired performance mode:
219:               // SYSCLK = 8 MHz, All PBCLKx = 8 MHz
220:               // Cache Disabled (per setting in "pic32_init_cache.S")
221:               // Pre-Fetch Disabled
222:               
223:               unsigned int cp0;
224:           	
225:               // Unlock Sequence
226:               asm volatile("di");     // disable all interrupts
227:               SYSKEY = 0xAA996655;
228:               SYSKEY = 0x556699AA;  
229:           
230:               // PB1DIV
231:                                       // Peripheral Bus 1 cannot be turned off, so there's no need to turn it on
232:               PB1DIVbits.PBDIV = 0;   // Peripheral Bus 1 Clock Divisor Control (PBCLK1 is SYSCLK divided by 1)
233:           
234:               // PB2DIV
235:               PB2DIVbits.ON = 1;      // Peripheral Bus 2 Output Clock Enable (Output clock is enabled)
236:               PB2DIVbits.PBDIV = 0;   // Peripheral Bus 2 Clock Divisor Control (PBCLK2 is SYSCLK divided by 1)
237:           
238:               // PB3DIV
239:               PB3DIVbits.ON = 1;      // Peripheral Bus 2 Output Clock Enable (Output clock is enabled)
240:               PB3DIVbits.PBDIV = 0;   // Peripheral Bus 3 Clock Divisor Control (PBCLK3 is SYSCLK divided by 1)
241:           
242:               // PB4DIV
243:               PB4DIVbits.ON = 1;      // Peripheral Bus 4 Output Clock Enable (Output clock is enabled)
244:               while (!PB4DIVbits.PBDIVRDY); // Wait until it is ready to write to
245:               PB4DIVbits.PBDIV = 0;   // Peripheral Bus 4 Clock Divisor Control (PBCLK4 is SYSCLK divided by 1)
246:           
247:               // PB5DIV
248:               PB5DIVbits.ON = 1;      // Peripheral Bus 5 Output Clock Enable (Output clock is enabled)
249:               PB5DIVbits.PBDIV = 0;   // Peripheral Bus 5 Clock Divisor Control (PBCLK5 is SYSCLK divided by 1)
250:           
251:               // PB7DIV
252:               PB7DIVbits.ON = 1;      // Peripheral Bus 7 Output Clock Enable (Output clock is enabled)
253:               PB7DIVbits.PBDIV = 0;   // Peripheral Bus 7 Clock Divisor Control (PBCLK7 is SYSCLK divided by 1)
254:           
255:               // PB8DIV
256:               PB8DIVbits.ON = 1;      // Peripheral Bus 8 Output Clock Enable (Output clock is enabled)
257:               PB8DIVbits.PBDIV = 0;   // Peripheral Bus 8 Clock Divisor Control (PBCLK8 is SYSCLK divided by 1)
258:           
259:               // PRECON - Set up prefetch (60 MHz operation))
260:               //PRECONbits.PFMSECEN = 0; // Flash SEC Interrupt Enable (Do not generate an interrupt when the PFMSEC bit is set)
261:               PRECONbits.PREFEN = 0b11; // Predictive Prefetch Enable (Enable predictive prefetch for any address)
262:               PRECONbits.PFMWS = 0b000; // PFM Access Time Defined in Terms of SYSCLK Wait States (Zero wait states @ 8 MHz)
263:           
264:               // Set up caching
265:               // See  https://microchipdeveloper.com/32bit:mz-cache-disable
266:               // Added "pic32_init_cache.S" to project from XC32 tool chain, and set __PIC32_CACHE_MODE to _CACHE_WRITEBACK_WRITEALLOCATE
267:           
268:               // Lock Sequence
269:               SYSKEY = 0x33333333;
270:               asm volatile("ei");     // Enable all interrupts
271:               
272:           #elif defined(PIC24FJ256GA702_BB)
273:               
274:               // At this point, the Hardware Clock Initialization is Complete
275:               // Primary OSC with 4X PLL provides 32 MHz Fosc (16 MIPs)
276:               
277:               // Need to set Fosc to 16 MHz (8 MIPs)
278:               
279:               CLKDIVbits.CPDIV = 0x01;    // Select DIV2 clock scaling (16 MHz, 8 MIPs)
280:               
281:           #endif
282:               
283:           }
0005  0008     RETURN
284:           
285:           void PinConfig(void){
286:               
287:           #if defined(PIC32MZ1024EFH064_MINI32_BB)
288:               
289:               // Set up PPS (I/O Pin-Mapping) for all I/O in this application
290:               // U2RX <-- RPD4   (DEBUG PORT PC-TX pin)
291:               // U2TX --> RPD5   (DEBUG PORT PC-RX pin)
292:               
293:               // U2RX pin (RPD4) is not an ADC input, so no need to configure ANSEL register
294:               
295:               // PPS unlock sequence
296:               SYSKEY = 0x0;         
297:               SYSKEY = 0xAA996655;         
298:               SYSKEY = 0x556699AA; 
299:               CFGCONbits.IOLOCK = 0;  // unlock PPS registers for writing
300:               
301:               // modify the PPS registers for the application (per table 11-2 in data sheet)
302:               U2RXRbits.U2RXR = 4;        // Map RPD04 to U2RX
303:               RPD5Rbits.RPD5R = 2;        // Map U2TX to RPD05 
304:               
305:               // PPS re-lock sequence
306:               CFGCONbits.IOLOCK = 1;         
307:               SYSKEY = 0x0;
308:               
309:           #elif defined(PIC32MX170F256B_BB)
310:               
311:               // Set up PPS (I/O Pin-Mapping) for all I/O in this application
312:               // U2RX <-- RPB11   (DEBUG PORT PC-TX pin)
313:               // U2TX --> RPB10   (DEBUG PORT PC-RX pin)
314:               
315:               // PPS unlock sequence
316:               SYSKEY = 0x0;         
317:               SYSKEY = 0xAA996655;         
318:               SYSKEY = 0x556699AA; 
319:               CFGCONbits.IOLOCK = 0;  // unlock PPS registers for writing
320:               
321:               // modify the PPS registers for the application (per table 11-2 in data sheet)
322:               U2RXR = 3;      // Map RPB11 to U2RX
323:               RPB10R = 2;     // Map U2TX to RPB10 
324:               
325:               // PPS re-lock sequence
326:               CFGCONbits.IOLOCK = 1;         
327:               SYSKEY = 0x0;
328:               
329:           #elif defined(PIC24FJ256GA702_BB)
330:               
331:               // Set up PPS (I/O Pin-Mapping) for all I/O in this application
332:               // U2RX <-- RP11   (DEBUG PORT PC-TX pin)
333:               // U2TX --> RP10   (DEBUG PORT PC-RX pin)
334:               // 1. Unlock PPS registers
335:               __builtin_write_OSCCONL(OSCCON & 0xBF);
336:               // 2. Configure Output Functions
337:               // Assign U2TX output function to pin RP10
338:               RPOR5bits.RP10R = 5;
339:               // 3. Configure Input Functions
340:               // Assign pin RP11 to U2RX input function
341:               RPINR19bits.U2RXR = 11;
342:               // 4 Lock the PPS registers
343:               __builtin_write_OSCCONL(OSCCON | 0x40);
344:               
345:           #elif defined(PIC16LF15356_BB)
346:               
347:               // Disable Analog function on PIC16 pins used for this function
348:               ANSELCbits.ANSC7 = 0;
0C53  017E     MOVLB 0x3E
0C54  13CE     BCF ANSELC, 0x7
349:               ANSELCbits.ANSC6 = 0;
0C55  134E     BCF ANSELC, 0x6
350:               
351:               // Configure digital pins
352:               TRISCbits.TRISC7 = 1;
0C56  0140     MOVLB 0x0
0C57  1794     BSF TRISC, 0x7
353:               TRISCbits.TRISC6 = 0;
0C58  1314     BCF TRISC, 0x6
354:               
355:               // Initiallize PPS Pin Mapping for this Application
356:               // TX2 --> RC6 
357:               // RX2 <-- RC7 
358:               // 1. Unlock PPS registers
359:               //bit oldGIE = INTCONbits.GIE;
360:               //INTCONbits.GIE = 0;
361:               PPSLOCK = 0x55;
0C59  3055     MOVLW 0x55
0C5A  017D     MOVLB 0x3D
0C5B  008F     MOVWF PPSLOCK
362:               PPSLOCK = 0xAA;
0C5C  30AA     MOVLW 0xAA
0C5D  008F     MOVWF PPSLOCK
363:               PPSLOCKbits.PPSLOCKED = 0;
0C5E  100F     BCF PPSLOCK, 0x0
364:               //INTCONbits.GIE = oldGIE;
365:               // 2. Configure Output Functions
366:               // Assign TX2 output function to pin RC6
367:               RC6PPS = 0x11;
0C5F  3011     MOVLW 0x11
0C60  017E     MOVLB 0x3E
0C61  00A6     MOVWF RC6PPS
368:               // 3. Configure Input Functions
369:               // Assign RC7 pin to RX2 input function
370:               RX2DTPPS = 0x17;
0C62  3017     MOVLW 0x17
0C63  017D     MOVLB 0x3D
0C64  00CD     MOVWF RX2DTPPS
371:               // 4 Lock the PPS registers
372:               //oldGIE = INTCONbits.GIE;
373:               //INTCONbits.GIE = 0;
374:               PPSLOCK = 0x55;
0C65  3055     MOVLW 0x55
0C66  008F     MOVWF PPSLOCK
375:               PPSLOCK = 0xAA;
0C67  30AA     MOVLW 0xAA
0C68  008F     MOVWF PPSLOCK
376:               PPSLOCKbits.PPSLOCKED = 1;
0C69  140F     BSF PPSLOCK, 0x0
377:               //INTCONbits.GIE = oldGIE;
378:               
379:           #elif defined(PIC16LF18456_BLE)
380:               
381:               // Disable Analog function on PIC16 pins used for this function
382:               ANSELBbits.ANSB4 = 0;
383:               ANSELBbits.ANSB5 = 0;
384:               
385:               // Configure digital pins
386:               TRISBbits.TRISB4 = 0;
387:               TRISBbits.TRISB5 = 1;
388:               
389:               // Initiallize PPS Pin Mapping for this Application
390:               // TX1 --> RB4 
391:               // RX1 <-- RB5 
392:               // 1. Unlock PPS registers
393:               //bit oldGIE = INTCONbits.GIE;
394:               //INTCONbits.GIE = 0;
395:               PPSLOCK = 0x55;
396:               PPSLOCK = 0xAA;
397:               PPSLOCKbits.PPSLOCKED = 0;
398:               //INTCONbits.GIE = oldGIE;
399:               // 2. Configure Output Functions
400:               // Assign TX1 output function to pin RB4
401:               RB4PPS = 0x0F;
402:               // 3. Configure Input Functions
403:               // Assign RB5 pin to RX1 input function
404:               RX1DTPPS = 0x0D;
405:               // 4 Lock the PPS registers
406:               //oldGIE = INTCONbits.GIE;
407:               //INTCONbits.GIE = 0;
408:               PPSLOCK = 0x55;
409:               PPSLOCK = 0xAA;
410:               PPSLOCKbits.PPSLOCKED = 1;
411:               //INTCONbits.GIE = oldGIE;
412:               
413:           #endif
414:           }
0C6A  0008     RETURN
415:           
416:           void UartConfig(void){
417:               
418:           #if defined(PIC32MZ1024EFH064_MINI32_BB)
419:               
420:               // Initialize UART2 for use as the DEBUG PORT for printf() messages
421:               
422:               // Note: No special initialization is required for printf()
423:               // printf() uses UART 2 for output by default as long as UART 2 is initialized before use
424:               
425:               U2MODEbits.UARTEN = 0;  // Disable UART  
426:               U2STAbits.UTXEN = 0;
427:               U2MODEbits.BRGH = 1;    // Enable high rate baud clock
428:               U2BRG = 16;             // Baud Rate generator set to 115200 baud
429:               U2MODEbits.UARTEN = 1;
430:               U2STAbits.UTXEN = 1;    // Enable UART
431:               
432:           #elif defined(PIC32MX170F256B_BB)
433:               
434:               // Initialize UART2 for use as the DEBUG PORT for printf() messages
435:               
436:               U2MODEbits.UARTEN = 0;  // Disable UART  
437:               U2STAbits.UTXEN = 0;
438:               U2MODEbits.BRGH = 1;    // Enable high rate baud clock
439:               U2BRG = 16;             // Baud Rate generator set to 115200 baud
440:               U2MODEbits.UARTEN = 1;
441:               U2STAbits.UTXEN = 1;    // Enable UART
442:               
443:           #elif defined(PIC24FJ256GA702_BB)
444:               
445:               // Initialize UART2 for use as the DEBUG PORT for printf() messages
446:               
447:               __C30_UART = 2;         // MACRO: Divert printf() output to UART 2 - see XC16 manual
448:               
449:               U2MODEbits.UARTEN = 0;  // Disable UART  
450:               U2STAbits.UTXEN = 0;
451:               U2MODEbits.BRGH = 1;    // Enable high rate baud clock
452:               U2BRG = 16;             // Baud Rate generator set to 115200 baud
453:               U2MODEbits.UARTEN = 1;
454:               U2STAbits.UTXEN = 1;    // Enable UART
455:               
456:           #elif defined(PIC16LF15356_BB)
457:               
458:               // Initialize UART2 for use as the DEBUG PORT for printf() messages
459:               
460:               // Turn the UART off
461:               RC2STAbits.SPEN = 0;
0C18  0154     MOVLB 0x14
0C19  139D     BCF RC2STA, 0x7
462:               TX2STAbits.TXEN = 0;
0C1A  129E     BCF TX2STA, 0x5
463:           
464:               // Disable U2 Interrupts
465:               PIR3bits.TX2IF = 0;                                                         // Clear the Transmit Interrupt Flag
0C1B  014E     MOVLB 0xE
0C1C  130F     BCF PIR3, 0x6
466:               PIE3bits.TX2IE = 0;                                                         // Disable Transmit Interrupts
0C1D  1319     BCF PIE3, 0x6
467:               PIR3bits.RC2IF = 0;                                                         // Clear the Receive Interrupt Flag
0C1E  138F     BCF PIR3, 0x7
468:               PIE3bits.RC2IE = 0;                                                         // Disable Receive Interrupts
0C1F  1399     BCF PIE3, 0x7
469:               
470:               // Configure TX Channel
471:               TX2STAbits.SYNC = 0;                                                        // Async mode
0C20  0154     MOVLB 0x14
0C21  121E     BCF TX2STA, 0x4
472:               TX2STAbits.BRGH = 1;                                                        // High speed BRG
0C22  151E     BSF TX2STA, 0x2
473:               
474:               // Configure RX Channel
475:               RC2STAbits.CREN = 1;                                                        // Enable continuous RX
0C23  161D     BSF RC2STA, 0x4
476:               
477:               // Configure BRG (BRGH = 1, BRG = 1)
478:               BAUD2CONbits.BRG16 = 1;
0C24  159F     BSF BAUD2CON, 0x3
479:               SP2BRGH = 0x00;
0C25  019C     CLRF SP2BRGH
480:               SP2BRGL = 0x44;               // decimal 68 (115200 baud)
0C26  3044     MOVLW 0x44
0C27  009B     MOVWF SP2BRG
481:               
482:               // ...And turn the UART on
483:               RC2STAbits.SPEN = 1;
0C28  179D     BSF RC2STA, 0x7
484:               TX2STAbits.TXEN = 1;
0C29  169E     BSF TX2STA, 0x5
485:               
486:           #elif defined(PIC16LF18456_BLE)
487:               
488:               // Initialize UART1 for use as the DEBUG PORT for printf() messages
489:               
490:               // Turn the UART off
491:               RC1STAbits.SPEN = 0;
492:               TX1STAbits.TXEN = 0;
493:           
494:               // Disable U1 Interrupts
495:               PIR3bits.TX1IF = 0;                                                         // Clear the Transmit Interrupt Flag
496:               PIE3bits.TX1IE = 0;                                                         // Disable Transmit Interrupts
497:               PIR3bits.RC1IF = 0;                                                         // Clear the Receive Interrupt Flag
498:               PIE3bits.RC1IE = 0;                                                         // Disable Receive Interrupts
499:               
500:               // Configure TX Channel
501:               TX1STAbits.SYNC = 0;                                                        // Async mode
502:               TX1STAbits.BRGH = 1;                                                        // High speed BRG
503:               
504:               // Configure RX Channel
505:               RC1STAbits.CREN = 1;                                                        // Enable continuous RX
506:               
507:               // Configure BRG (BRGH = 1, BRG = 1)
508:               BAUD1CONbits.BRG16 = 1;
509:               SP1BRGH = 0x00;
510:               SP1BRGL = 0x44;               // decimal 68 (115200 baud)
511:               
512:               // ...And turn the UART on
513:               RC1STAbits.SPEN = 1;
514:               TX1STAbits.TXEN = 1;    
515:               
516:           #endif
517:               
518:           }
0C2A  0008     RETURN
519:           
520:           #if defined(PIC16LF15356_BB)
521:               
522:           // XC8 Stub required to redirect printf() statements to UART 2
523:           
524:           void putch(char c) {
0BEE  00F0     MOVWF 0xA70
525:           while(!TX2STAbits.TRMT);   // wait while Tx buffer full
0BEF  0154     MOVLB 0x14
0BF0  1C9E     BTFSS TX2STA, 0x1
0BF1  2BF3     GOTO 0x3F3
0BF2  2BF4     GOTO 0x3F4
0BF3  2BEF     GOTO 0x3EF
526:           TX2REG = c;
0BF4  0870     MOVF 0xA70, W
0BF5  009A     MOVWF TX2REG
527:           }
0BF6  0008     RETURN
528:           
529:           //void putch(char c) {
530:           //    while(!PIR3bits.TX2IF) // check buffer
531:           //    continue; // wait till ready
532:           //    TX2REG = c; // send data
533:           //}
534:           
535:           #elif defined(PIC16LF18456_BLE)
536:               
537:           // XC8 Stub required to redirect printf() statements to UART 1
538:           
539:           void putch(char c) {
540:           while(!TX1STAbits.TRMT);   // wait while Tx buffer full
541:           TX2REG = c;
542:           }
543:           
544:           //void putch(char c) {
545:           //    while(!PIR3bits.TX2IF) // check buffer
546:           //    continue; // wait till ready
547:           //    TX2REG = c; // send data
548:           //}
549:           
550:           #endif
551:           
552:           void StopwatchConfig(void){
553:               
554:               // The MCU should ideally have a 16-bit timer resource available that
555:               // can be clocked at the CPU's frequency, and whose count value can be read
556:               // atomically.
557:               
558:           #if defined(PIC32MZ1024EFH064_MINI32_BB)
559:               
560:               // Use Timer 2 (clocked at PBCLK, which is set to CPUCLK via Initialization)
561:               
562:               T2CONbits.TON = 0;      // Disable Timer
563:               T2CONbits.TCS = 0;      // Select internal PBCLK as clock source
564:               T2CONbits.TGATE = 0;    // Disable gated timer mode
565:               T2CONbits.TCKPS = 0;    // Select 1:1 CLK prescale
566:               
567:           #elif defined(PIC32MX170F256B_BB)
568:               
569:               // Use Timer 2 (clocked at PBCLK, which is set to CPUCLK via Initialization)
570:               
571:               T2CONbits.TON = 0;      // Disable Timer
572:               T2CONbits.TCS = 0;      // Select internal PBCLK as clock source
573:               T2CONbits.TGATE = 0;    // Disable gated timer mode
574:               T2CONbits.TCKPS = 0;    // Select 1:1 CLK prescale
575:                   
576:           #elif defined(PIC24FJ256GA702_BB)
577:               
578:               // Use Timer 2 (clocked at PBCLK, which is set to CPUCLK via Initialization)
579:               
580:               T2CONbits.TON = 0;      // Disable Timer
581:               T2CONbits.TCS = 0;      // Select internal PBCLK as clock source
582:               T2CONbits.TGATE = 0;    // Disable gated timer mode
583:               T2CONbits.TCKPS = 0;    // Select 1:1 CLK prescale
584:            
585:           #elif defined(PIC16LF15356_BB)
586:               
587:               // Use Timer 1 (clocked at Fosc/4 = 8 MIPs)
588:               
589:               T1CONbits.ON = 0;       // Disable Timer
0BE0  0144     MOVLB 0x4
0BE1  100E     BCF T1CON, 0x0
590:               T1CLKbits.CS = 1;       // CLK source = Fosc/4 = Fcyc
0BE2  0811     MOVF T1CLK, W
0BE3  39F0     ANDLW 0xF0
0BE4  3801     IORLW 0x1
0BE5  0091     MOVWF T1CLK
591:               
592:               // Use Timer 0 (clocked at Fosc/4 = 8 MIPs)
593:           //    T0CON0bits.T0EN = 0;    // Disable Timer
594:           //    T0CON0bits.T016BIT = 1; // Enable 16-bit TMR0 register read/write operation.
595:           //    T0CON1bits.T0CS = 2;    // CLK source = Fosc/4 = Fcyc
596:               
597:           #elif defined(PIC16LF18456_BLE)
598:               
599:               // Use Timer 1 (clocked at Fosc/4 = 8 MIPs)
600:               
601:               T1CONbits.ON = 0;       // Disable Timer
602:               T1CONbits.RD16 = 1;     // Enable 16-bit TMR1 register read/write in 1 operation.
603:               T1CLKbits.CS = 1;       // CLK source = Fosc/4 = Fcyc
604:               
605:               // Use Timer 0 (clocked at Fosc/4 = 8 MIPs)
606:           //    T0CON0bits.T0EN = 0;    // Disable Timer
607:           //    T0CON0bits.T016BIT = 1; // Enable 16-bit TMR0 register read/write operation.
608:           //    T0CON1bits.T0CS = 2;    // CLK source = Fosc/4 = Fcyc    
609:               
610:           #endif
611:               
612:           }
0BE6  0008     RETURN
613:           
614:           void StopwatchRestart(void){
615:               
616:           #if defined(PIC16LF15356_BB)
617:               
618:               TMR1H = 0;
0BCF  0144     MOVLB 0x4
0BD0  018D     CLRF TMR1H
619:               TMR1L = 0;
0BD1  018C     CLRF TMR1
620:               T1CONbits.ON = 1;
0BD2  140E     BSF T1CON, 0x0
621:               
622:           //    T0CON0bits.T0EN = 0;
623:           //    TMR0H = 0;
624:           //    TMR0L = 0;
625:           //    T0CON0bits.T0EN = 1;
626:               
627:           #elif defined(PIC16LF18456_BLE)
628:               
629:               T1CONbits.ON = 0;
630:               NoOP();
631:               TMR1H = 0;
632:               TMR1L = 0;
633:               T1CONbits.ON = 1;
634:               
635:           //    T0CON0bits.T0EN = 0;
636:           //    TMR0H = 0;
637:           //    TMR0L = 0;
638:           //    T0CON0bits.T0EN = 1;    
639:               
640:           #elif defined(PIC24FJ256GA702_BB)
641:               
642:               T2CONbits.TON = 0;
643:               TMR2 = 0;
644:               T2CONbits.TON = 1;
645:               
646:           #elif defined(PIC32MX170F256B_BB)
647:           
648:               T2CONbits.ON = 0;
649:               TMR2 = 0;
650:               T2CONbits.ON = 1;
651:               
652:           #elif defined(PIC32MZ1024EFH064_MINI32_BB)
653:           
654:               T2CONbits.ON = 0;
655:               TMR2 = 0;
656:               T2CONbits.ON = 1;    
657:               
658:           #endif
659:           }
0BD3  0008     RETURN
660:           
661:           uint16_t StopwatchRead(void){
662:               
663:               elapsedTime tmp;
664:               
665:           #if defined(PIC16LF15356_BB)
666:               
667:               T1CONbits.ON = 0;
0BF7  0144     MOVLB 0x4
0BF8  100E     BCF T1CON, 0x0
668:               tmp.Low = TMR1L;
0BF9  080C     MOVF TMR1, W
0BFA  00F2     MOVWF 0x272
0BFB  0872     MOVF 0x272, W
0BFC  00F3     MOVWF 0x273
669:               tmp.High = TMR1H;
0BFD  080D     MOVF TMR1H, W
0BFE  00F2     MOVWF 0x272
0BFF  0872     MOVF 0x272, W
0C00  00F4     MOVWF 0x274
670:               
671:               //tmp.Full = TMR1;
672:               //T1CONbits.ON = 0;
673:               return tmp.Full;
0C01  0874     MOVF 0x274, W
0C02  00F1     MOVWF 0x271
0C03  0873     MOVF 0x273, W
0C04  00F0     MOVWF 0x270
674:               
675:           //    tmp.Low = TMR0L;
676:           //    tmp.High = TMR0H;
677:           //    T0CON0bits.T0EN = 0;
678:           //    return tmp.Full;
679:               
680:           #elif defined(PIC16LF18456_BLE)
681:               
682:               tmp.Low = TMR1L;
683:               tmp.High = TMR1H;
684:               
685:               //tmp.Full = TMR1;
686:               T1CONbits.ON = 0;
687:               return tmp.Full;
688:               
689:           //    tmp.Low = TMR0L;
690:           //    tmp.High = TMR0H;
691:           //    T0CON0bits.T0EN = 0;
692:           //    return tmp.Full;    
693:               
694:           #elif defined(PIC24FJ256GA702_BB)
695:               
696:               tmp.Full = TMR2;
697:               T2CONbits.TON = 0;
698:               return tmp.Full;
699:               
700:           #elif defined(PIC32MX170F256B_BB)
701:           
702:               tmp.Full = TMR2;
703:               T2CONbits.ON = 0;
704:               return tmp.Full;
705:               
706:           #elif defined(PIC32MZ1024EFH064_MINI32_BB)
707:           
708:               tmp.Full = TMR2;
709:               T2CONbits.ON = 0;
710:               return tmp.Full;    
711:               
712:           #endif
713:           }
0C05  0008     RETURN
714:           
715:           int8_t sum8(int8_t a, int8_t b) {
0BCB  00F1     MOVWF 0x271
716:               return (a + b);
0BCC  0871     MOVF 0x271, W
0BCD  0770     ADDWF 0x270, W
717:           }
0BCE  0008     RETURN
718:           
719:           int32_t sum32(int32_t a, int32_t b) {
720:             return (a + b);
0C3E  0870     MOVF 0x270, W
0C3F  0774     ADDWF 0x274, W
0C40  00F8     MOVWF 0x278
0C41  0871     MOVF 0x271, W
0C42  3D75     ADDWFC 0x275, W
0C43  00F9     MOVWF 0x279
0C44  0872     MOVF 0x272, W
0C45  3D76     ADDWFC 0x276, W
0C46  00FA     MOVWF 0x27A
0C47  0873     MOVF 0x273, W
0C48  3D77     ADDWFC 0x277, W
0C49  00FB     MOVWF 0x27B
0C4A  087B     MOVF 0x27B, W
0C4B  00F3     MOVWF 0x273
0C4C  087A     MOVF 0x27A, W
0C4D  00F2     MOVWF 0x272
0C4E  0879     MOVF 0x279, W
0C4F  00F1     MOVWF 0x271
0C50  0878     MOVF 0x278, W
0C51  00F0     MOVWF 0x270
721:           }
0C52  0008     RETURN
722:           
723:           int16_t mul8(int8_t a, int8_t b) {
0C2B  00F9     MOVWF 0x279
724:               return (a * b);
0C2C  0879     MOVF 0x279, W
0C2D  00F0     MOVWF 0x270
0C2E  01F1     CLRF 0x271
0C2F  1BF0     BTFSC 0x270, 0x7
0C30  03F1     DECF 0x271, F
0C31  0876     MOVF 0x276, W
0C32  00F2     MOVWF 0x272
0C33  01F3     CLRF 0x273
0C34  1BF2     BTFSC 0x272, 0x7
0C35  03F3     DECF 0x273, F
0C36  318C     MOVLP 0xC
0C37  249E     CALL 0x49E
0C38  318C     MOVLP 0xC
0C39  0871     MOVF 0x271, W
0C3A  00F7     MOVWF 0x277
0C3B  0870     MOVF 0x270, W
0C3C  00F6     MOVWF 0x276
725:           }
0C3D  0008     RETURN
726:           
727:           int64_t mul32(int32_t a, int32_t b) {
728:             return (a * b);
0CE0  0140     MOVLB 0x0
0CE1  0823     MOVF s, W
0CE2  00F3     MOVWF a
0CE3  0822     MOVF 0x22, W
0CE4  00F2     MOVWF sign
0CE5  0821     MOVF i, W
0CE6  00F1     MOVWF counter
0CE7  0820     MOVF __pcstackBANK0, W
0CE8  00F0     MOVWF __pcstackCOMMON
0CE9  0827     MOVF i, W
0CEA  00F7     MOVWF 0x77
0CEB  0826     MOVF 0x26, W
0CEC  00F6     MOVWF b
0CED  0825     MOVF p, W
0CEE  00F5     MOVWF 0x75
0CEF  0824     MOVF b, W
0CF0  00F4     MOVWF multiplicand
0CF1  3180     MOVLP 0x0
0CF2  2006     CALL 0x6
0CF3  318C     MOVLP 0xC
0CF4  0870     MOVF __pcstackCOMMON, W
0CF5  0140     MOVLB 0x0
0CF6  00A0     MOVWF __pcstackBANK0
0CF7  0871     MOVF counter, W
0CF8  00A1     MOVWF i
0CF9  0872     MOVF sign, W
0CFA  00A2     MOVWF 0x22
0CFB  0873     MOVF a, W
0CFC  00A3     MOVWF s
0CFD  3000     MOVLW 0x0
0CFE  1BA3     BTFSC s, 0x7
0CFF  30FF     MOVLW 0xFF
0D00  00A4     MOVWF b
0D01  00A5     MOVWF p
0D02  00A6     MOVWF 0x26
0D03  00A7     MOVWF i
729:           }
0D04  0008     RETURN
---  /Applications/microchip/xc8/v2.20/pic/sources/c99/common/strlen.c  ---------------------------------
1:             #include <string.h>
2:             #include <stdint.h>
3:             #include <limits.h>
4:             
5:             size_t strlen(const char *s)
6:             {
7:             	const char *a = s;
0C6B  0871     MOVF counter, W
0C6C  00F4     MOVWF multiplicand
0C6D  0870     MOVF __pcstackCOMMON, W
0C6E  00F3     MOVWF a
8:             	while(*s) {
0C6F  2C74     GOTO 0x474
0C74  0870     MOVF __pcstackCOMMON, W
0C75  0084     MOVWF FSR0
0C76  0871     MOVF counter, W
0C77  0085     MOVWF FSR0H
0C78  0012     MOVIW FSR0++
0C79  1D03     BTFSS STATUS, 0x2
0C7A  2C7C     GOTO 0x47C
0C7B  2C7D     GOTO 0x47D
0C7C  2C70     GOTO 0x470
9:             		s++;
0C70  3001     MOVLW 0x1
0C71  07F0     ADDWF __pcstackCOMMON, F
0C72  3000     MOVLW 0x0
0C73  3DF1     ADDWFC counter, F
10:            	}
11:            	return s-a;
0C7D  0873     MOVF a, W
0C7E  0270     SUBWF __pcstackCOMMON, W
0C7F  00F0     MOVWF __pcstackCOMMON
0C80  0874     MOVF multiplicand, W
0C81  3B71     SUBWFB counter, W
0C82  00F1     MOVWF counter
12:            }
0C83  0008     RETURN
---  /Applications/microchip/xc8/v2.20/pic/sources/c99/common/sprcmul.c  --------------------------------
1:             /* SP relaxed compliance floating point multiply intrinsic function */
2:             #include <stdint.h>
3:             #include "fpform.h"
4:             
5:             /* SP Multiply */
6:             /* single monolithic routine */
7:             SP
8:             SPMUL(SP b, SP a) {
9:             	unsigned char sign;	/* sign of result */
10:            	unsigned char bexp;	/* Dst exponent */
11:            	unsigned char aexp;	/* Src exponent */
12:            	uint32_t grs;		/* Guard, round, sticky */
13:            	SFP prod;
14:            	wordProduct temp;	/* intermediate mult results ; exponent of result */
15:            
16:            	/* Unpack and check operands */
17:            	sign = (*(SFP *) & b).fAsBytes.d & 0x80;
058A  0140     MOVLB 0x0
058B  0823     MOVF s, W
058C  3980     ANDLW 0x80
058D  00F9     MOVWF fp
058E  0879     MOVF fp, W
058F  00A8     MOVWF dividend
18:            	bexp = ((*(SFP *) & b).fAsBytes.d) << 1;
0590  3523     LSLF s, W
0591  00F9     MOVWF fp
0592  0879     MOVF fp, W
0593  00AE     MOVWF bexp
19:            	if ((*(SFP *) & b).fAsBytes.c & 0x80) {
0594  1FA2     BTFSS 0x22, 0x7
0595  2D97     GOTO 0x597
0596  2D98     GOTO 0x598
0597  2D99     GOTO 0x599
20:            		bexp |= 0x1;
0598  142E     BSF bexp, 0x0
21:            	}
22:            
23:            	/* Destination normal ? */
24:            	if (bexp) {
0599  082E     MOVF bexp, W
059A  1903     BTFSC STATUS, 0x2
059B  2D9D     GOTO 0x59D
059C  2D9E     GOTO 0x59E
059D  2DAD     GOTO 0x5AD
25:            		/* Destination inf or NaN ? */
26:            		if (bexp == 0xFF) {
059E  0A2E     INCF bexp, W
059F  1D03     BTFSS STATUS, 0x2
05A0  2DA2     GOTO 0x5A2
05A1  2DA3     GOTO 0x5A3
05A2  2DAB     GOTO 0x5AB
27:            			/* Make it inf */
28:            			b = 0;
05A3  3000     MOVLW 0x0
05A4  00A3     MOVWF s
05A5  3000     MOVLW 0x0
05A6  00A2     MOVWF 0x22
05A7  3000     MOVLW 0x0
05A8  00A1     MOVWF i
05A9  3000     MOVLW 0x0
05AA  00A0     MOVWF __pcstackBANK0
29:            		}
30:            		// and in the implied 1-bit to b's fraction
31:            		(*(SFP *) & b).i |= (int32_t) 1 << SPFRCB;
05AB  17A2     BSF 0x22, 0x7
32:            
33:            	}
05AC  2DB5     GOTO 0x5B5
34:            	else {
35:            		/* Make it zero */
36:            		b = 0;
05AD  3000     MOVLW 0x0
05AE  00A3     MOVWF s
05AF  3000     MOVLW 0x0
05B0  00A2     MOVWF 0x22
05B1  3000     MOVLW 0x0
05B2  00A1     MOVWF i
05B3  3000     MOVLW 0x0
05B4  00A0     MOVWF __pcstackBANK0
37:            	}
38:            
39:            	sign ^= (*(SFP *) & a).fAsBytes.d & 0x80;
05B5  0827     MOVF i, W
05B6  3980     ANDLW 0x80
05B7  00F9     MOVWF fp
05B8  0879     MOVF fp, W
05B9  06A8     XORWF dividend, F
40:            	aexp = ((*(SFP *) & a).fAsBytes.d) << 1;
05BA  3527     LSLF i, W
05BB  00F9     MOVWF fp
05BC  0879     MOVF fp, W
05BD  00AD     MOVWF aexp
41:            	if ((*(SFP *) & a).fAsBytes.c & 0x80) {
05BE  1FA6     BTFSS 0x26, 0x7
05BF  2DC1     GOTO 0x5C1
05C0  2DC2     GOTO 0x5C2
05C1  2DC3     GOTO 0x5C3
42:            		aexp |= 0x1;
05C2  142D     BSF aexp, 0x0
43:            	}
44:            	/* Destination normal ? */
45:            	if (aexp) {
05C3  082D     MOVF aexp, W
05C4  1903     BTFSC STATUS, 0x2
05C5  2DC7     GOTO 0x5C7
05C6  2DC8     GOTO 0x5C8
05C7  2DD7     GOTO 0x5D7
46:            
47:            		/* Destination inf or NaN ? */
48:            		if (aexp == 0xFF) {
05C8  0A2D     INCF aexp, W
05C9  1D03     BTFSS STATUS, 0x2
05CA  2DCC     GOTO 0x5CC
05CB  2DCD     GOTO 0x5CD
05CC  2DD5     GOTO 0x5D5
49:            			/* Make it inf */
50:            			a = 0;
05CD  3000     MOVLW 0x0
05CE  00A7     MOVWF i
05CF  3000     MOVLW 0x0
05D0  00A6     MOVWF 0x26
05D1  3000     MOVLW 0x0
05D2  00A5     MOVWF p
05D3  3000     MOVLW 0x0
05D4  00A4     MOVWF b
51:            		}
52:            		// and in the implied 1-bit to a's fraction
53:            		(*(SFP *) & a).i |= (int32_t) 1 << SPFRCB;
05D5  17A6     BSF 0x26, 0x7
54:            	}
05D6  2DDF     GOTO 0x5DF
55:            	else {
56:            		/* Make it zero */
57:            		a = 0;
05D7  3000     MOVLW 0x0
05D8  00A7     MOVWF i
05D9  3000     MOVLW 0x0
05DA  00A6     MOVWF 0x26
05DB  3000     MOVLW 0x0
05DC  00A5     MOVWF p
05DD  3000     MOVLW 0x0
05DE  00A4     MOVWF b
58:            	}
59:            
60:            	/* Multiply */
61:            
62:            	/* Special operand check */
63:            
64:            	/* Source or destination zero ? Result zero */
65:            	if (aexp == 0 || bexp == 0) {
05DF  082D     MOVF aexp, W
05E0  1903     BTFSC STATUS, 0x2
05E1  2DE3     GOTO 0x5E3
05E2  2DE4     GOTO 0x5E4
05E3  2DE9     GOTO 0x5E9
05E4  082E     MOVF bexp, W
05E5  1D03     BTFSS STATUS, 0x2
05E6  2DE8     GOTO 0x5E8
05E7  2DE9     GOTO 0x5E9
05E8  2DF2     GOTO 0x5F2
66:            		return 0.0;
05E9  3000     MOVLW 0x0
05EA  00A3     MOVWF s
05EB  3000     MOVLW 0x0
05EC  00A2     MOVWF 0x22
05ED  3000     MOVLW 0x0
05EE  00A1     MOVWF i
05EF  3000     MOVLW 0x0
05F0  00A0     MOVWF __pcstackBANK0
05F1  2FE0     GOTO 0x7E0
67:            	}
68:            
69:            //    we decompose a 24 bit multiply into 9 8 bit multiplies as follows:
70:            //
71:            //    b's fraction is b1|b2|b3 and a's fraction is a1|a2|a3
72:            //
73:            //    then ab is the (48 bit) sum of these 9 16 bit intermediate products shifted appropriately
74:            //
75:            //
76:            //                                     a3b3
77:            //                                   a2b3
78:            //                                   a3b2
79:            //                                 a1b3
80:            //                                 a2b2
81:            //                                 a3b1
82:            //                               a1b2
83:            //                               a2b1
84:            //                             a1b1
85:            //
86:            //   in this algorithm we compute the product to be the upper 24 bits of the sum and grs to be the lower 24 bits
87:            //   shifted 8 to the left     then we renormalize and round as usual.
88:            //
89:            
90:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
91:            #define MIDBYTE(x)  (*(((unsigned char *)(&x))+1))
92:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+2))
93:            
94:            #ifdef _PIC18
95:            	temp.n = HIGHBYTE(a) * LOWBYTE(b);
96:            	grs = temp.nAsBytes.a;
97:            	prod.i = temp.nAsBytes.b;
98:            	temp.n = MIDBYTE(a) * MIDBYTE(b);
99:            	grs += temp.nAsBytes.a;
100:           	prod.i += temp.nAsBytes.b;
101:           	temp.n = LOWBYTE(a) * HIGHBYTE(b);
102:           	grs += temp.nAsBytes.a;
103:           	prod.i += temp.nAsBytes.b;
104:           	grs <<= 8;
105:           	temp.n = LOWBYTE(a) * MIDBYTE(b);
106:           	grs += (unsigned long)temp.n;
107:           	temp.n = MIDBYTE(a) * LOWBYTE(b);
108:           	grs += (unsigned long)temp.n;
109:           	grs <<= 8;
110:           	temp.n = LOWBYTE(a) * LOWBYTE(b);
111:           	grs += (unsigned long)temp.n;
112:           	temp.n = HIGHBYTE(a) * MIDBYTE(b);
113:           	prod.i += (unsigned long)temp.n;
114:           	temp.n = MIDBYTE(a) * HIGHBYTE(b);
115:           	prod.i += (unsigned long)temp.n;
116:           	temp.n = HIGHBYTE(a) * HIGHBYTE(b);
117:           	prod.i += (((unsigned long)temp.n) << 8);
118:           #else
119:           	temp.n = _Umul8_16(HIGHBYTE(a), LOWBYTE(b));
05F2  0820     MOVF __pcstackBANK0, W
05F3  00F9     MOVWF fp
05F4  0879     MOVF fp, W
05F5  00F0     MOVWF __pcstackCOMMON
05F6  0826     MOVF 0x26, W
05F7  318C     MOVLP 0xC
05F8  24BD     CALL 0x4BD
05F9  3185     MOVLP 0x5
05FA  0871     MOVF counter, W
05FB  0140     MOVLB 0x0
05FC  00B4     MOVWF 0x34
05FD  0870     MOVF __pcstackCOMMON, W
05FE  00B3     MOVWF temp
120:           	grs = temp.nAsBytes.a;
05FF  0833     MOVF temp, W
0600  00F9     MOVWF fp
0601  01FA     CLRF 0x7A
0602  01FB     CLRF 0x7B
0603  01FC     CLRF 0x7C
0604  087C     MOVF 0x7C, W
0605  00AC     MOVWF 0x2C
0606  087B     MOVF 0x7B, W
0607  00AB     MOVWF cp
0608  087A     MOVF 0x7A, W
0609  00AA     MOVWF 0x2A
060A  0879     MOVF fp, W
060B  00A9     MOVWF grs
121:           	prod.i = temp.nAsBytes.b;
060C  0834     MOVF 0x34, W
060D  00F9     MOVWF fp
060E  01FA     CLRF 0x7A
060F  01FB     CLRF 0x7B
0610  01FC     CLRF 0x7C
0611  087C     MOVF 0x7C, W
0612  00B2     MOVWF 0x32
0613  087B     MOVF 0x7B, W
0614  00B1     MOVWF 0x31
0615  087A     MOVF 0x7A, W
0616  00B0     MOVWF d
0617  0879     MOVF fp, W
0618  00AF     MOVWF prod
122:           	temp.n = _Umul8_16(MIDBYTE(a), MIDBYTE(b));
0619  0821     MOVF i, W
061A  00F9     MOVWF fp
061B  0879     MOVF fp, W
061C  00F0     MOVWF __pcstackCOMMON
061D  0825     MOVF p, W
061E  318C     MOVLP 0xC
061F  24BD     CALL 0x4BD
0620  3185     MOVLP 0x5
0621  0871     MOVF counter, W
0622  0140     MOVLB 0x0
0623  00B4     MOVWF 0x34
0624  0870     MOVF __pcstackCOMMON, W
0625  00B3     MOVWF temp
123:           	grs += temp.nAsBytes.a;
0626  0833     MOVF temp, W
0627  00F9     MOVWF fp
0628  01FA     CLRF 0x7A
0629  01FB     CLRF 0x7B
062A  01FC     CLRF 0x7C
062B  0879     MOVF fp, W
062C  07A9     ADDWF grs, F
062D  087A     MOVF 0x7A, W
062E  3DAA     ADDWFC 0x2A, F
062F  087B     MOVF 0x7B, W
0630  3DAB     ADDWFC cp, F
0631  087C     MOVF 0x7C, W
0632  3DAC     ADDWFC 0x2C, F
124:           	prod.i += temp.nAsBytes.b;
0633  0834     MOVF 0x34, W
0634  00F9     MOVWF fp
0635  01FA     CLRF 0x7A
0636  01FB     CLRF 0x7B
0637  01FC     CLRF 0x7C
0638  0879     MOVF fp, W
0639  07AF     ADDWF prod, F
063A  087A     MOVF 0x7A, W
063B  3DB0     ADDWFC d, F
063C  087B     MOVF 0x7B, W
063D  3DB1     ADDWFC 0x31, F
063E  087C     MOVF 0x7C, W
063F  3DB2     ADDWFC 0x32, F
125:           	temp.n = _Umul8_16(LOWBYTE(a), HIGHBYTE(b));
0640  0822     MOVF 0x22, W
0641  00F9     MOVWF fp
0642  0879     MOVF fp, W
0643  00F0     MOVWF __pcstackCOMMON
0644  0824     MOVF b, W
0645  318C     MOVLP 0xC
0646  24BD     CALL 0x4BD
0647  3185     MOVLP 0x5
0648  0871     MOVF counter, W
0649  0140     MOVLB 0x0
064A  00B4     MOVWF 0x34
064B  0870     MOVF __pcstackCOMMON, W
064C  00B3     MOVWF temp
126:           	grs += temp.nAsBytes.a;
064D  0833     MOVF temp, W
064E  00F9     MOVWF fp
064F  01FA     CLRF 0x7A
0650  01FB     CLRF 0x7B
0651  01FC     CLRF 0x7C
0652  0879     MOVF fp, W
0653  07A9     ADDWF grs, F
0654  087A     MOVF 0x7A, W
0655  3DAA     ADDWFC 0x2A, F
0656  087B     MOVF 0x7B, W
0657  3DAB     ADDWFC cp, F
0658  087C     MOVF 0x7C, W
0659  3DAC     ADDWFC 0x2C, F
127:           	prod.i += temp.nAsBytes.b;
065A  0834     MOVF 0x34, W
065B  00F9     MOVWF fp
065C  01FA     CLRF 0x7A
065D  01FB     CLRF 0x7B
065E  01FC     CLRF 0x7C
065F  0879     MOVF fp, W
0660  07AF     ADDWF prod, F
0661  087A     MOVF 0x7A, W
0662  3DB0     ADDWFC d, F
0663  087B     MOVF 0x7B, W
0664  3DB1     ADDWFC 0x31, F
0665  087C     MOVF 0x7C, W
0666  3DB2     ADDWFC 0x32, F
128:           	grs <<= 8;
0667  3008     MOVLW 0x8
0668  35A9     LSLF grs, F
0669  0DAA     RLF 0x2A, F
066A  0DAB     RLF cp, F
066B  0DAC     RLF 0x2C, F
066C  0B89     DECFSZ WREG, F
066D  2E68     GOTO 0x668
129:           	temp.n = _Umul8_16(LOWBYTE(a), MIDBYTE(b));
066E  0821     MOVF i, W
066F  00F9     MOVWF fp
0670  0879     MOVF fp, W
0671  00F0     MOVWF __pcstackCOMMON
0672  0824     MOVF b, W
0673  318C     MOVLP 0xC
0674  24BD     CALL 0x4BD
0675  3185     MOVLP 0x5
0676  0871     MOVF counter, W
0677  0140     MOVLB 0x0
0678  00B4     MOVWF 0x34
0679  0870     MOVF __pcstackCOMMON, W
067A  00B3     MOVWF temp
130:           	grs += (unsigned long)temp.n;
067B  0833     MOVF temp, W
067C  07A9     ADDWF grs, F
067D  0834     MOVF 0x34, W
067E  3DAA     ADDWFC 0x2A, F
067F  3000     MOVLW 0x0
0680  3DAB     ADDWFC cp, F
0681  3DAC     ADDWFC 0x2C, F
131:           	temp.n = _Umul8_16(MIDBYTE(a), LOWBYTE(b));
0682  0820     MOVF __pcstackBANK0, W
0683  00F9     MOVWF fp
0684  0879     MOVF fp, W
0685  00F0     MOVWF __pcstackCOMMON
0686  0825     MOVF p, W
0687  318C     MOVLP 0xC
0688  24BD     CALL 0x4BD
0689  3185     MOVLP 0x5
068A  0871     MOVF counter, W
068B  0140     MOVLB 0x0
068C  00B4     MOVWF 0x34
068D  0870     MOVF __pcstackCOMMON, W
068E  00B3     MOVWF temp
132:           	grs += (unsigned long)temp.n;
068F  0833     MOVF temp, W
0690  07A9     ADDWF grs, F
0691  0834     MOVF 0x34, W
0692  3DAA     ADDWFC 0x2A, F
0693  3000     MOVLW 0x0
0694  3DAB     ADDWFC cp, F
0695  3DAC     ADDWFC 0x2C, F
133:           	grs <<= 8;
0696  3008     MOVLW 0x8
0697  35A9     LSLF grs, F
0698  0DAA     RLF 0x2A, F
0699  0DAB     RLF cp, F
069A  0DAC     RLF 0x2C, F
069B  0B89     DECFSZ WREG, F
069C  2E97     GOTO 0x697
134:           	temp.n = _Umul8_16(LOWBYTE(a), LOWBYTE(b));
069D  0820     MOVF __pcstackBANK0, W
069E  00F9     MOVWF fp
069F  0879     MOVF fp, W
06A0  00F0     MOVWF __pcstackCOMMON
06A1  0824     MOVF b, W
06A2  318C     MOVLP 0xC
06A3  24BD     CALL 0x4BD
06A4  3185     MOVLP 0x5
06A5  0871     MOVF counter, W
06A6  0140     MOVLB 0x0
06A7  00B4     MOVWF 0x34
06A8  0870     MOVF __pcstackCOMMON, W
06A9  00B3     MOVWF temp
135:           	grs += (unsigned long)temp.n;
06AA  0833     MOVF temp, W
06AB  07A9     ADDWF grs, F
06AC  0834     MOVF 0x34, W
06AD  3DAA     ADDWFC 0x2A, F
06AE  3000     MOVLW 0x0
06AF  3DAB     ADDWFC cp, F
06B0  3DAC     ADDWFC 0x2C, F
136:           	temp.n = _Umul8_16(HIGHBYTE(a), MIDBYTE(b));
06B1  0821     MOVF i, W
06B2  00F9     MOVWF fp
06B3  0879     MOVF fp, W
06B4  00F0     MOVWF __pcstackCOMMON
06B5  0826     MOVF 0x26, W
06B6  318C     MOVLP 0xC
06B7  24BD     CALL 0x4BD
06B8  3185     MOVLP 0x5
06B9  0871     MOVF counter, W
06BA  0140     MOVLB 0x0
06BB  00B4     MOVWF 0x34
06BC  0870     MOVF __pcstackCOMMON, W
06BD  00B3     MOVWF temp
137:           	prod.i += (unsigned long)temp.n;
06BE  0833     MOVF temp, W
06BF  07AF     ADDWF prod, F
06C0  0834     MOVF 0x34, W
06C1  3DB0     ADDWFC d, F
06C2  3000     MOVLW 0x0
06C3  3DB1     ADDWFC 0x31, F
06C4  3DB2     ADDWFC 0x32, F
138:           	temp.n = _Umul8_16(MIDBYTE(a), HIGHBYTE(b));
06C5  0822     MOVF 0x22, W
06C6  00F9     MOVWF fp
06C7  0879     MOVF fp, W
06C8  00F0     MOVWF __pcstackCOMMON
06C9  0825     MOVF p, W
06CA  318C     MOVLP 0xC
06CB  24BD     CALL 0x4BD
06CC  3185     MOVLP 0x5
06CD  0871     MOVF counter, W
06CE  0140     MOVLB 0x0
06CF  00B4     MOVWF 0x34
06D0  0870     MOVF __pcstackCOMMON, W
06D1  00B3     MOVWF temp
139:           	prod.i += (unsigned long)temp.n;
06D2  0833     MOVF temp, W
06D3  07AF     ADDWF prod, F
06D4  0834     MOVF 0x34, W
06D5  3DB0     ADDWFC d, F
06D6  3000     MOVLW 0x0
06D7  3DB1     ADDWFC 0x31, F
06D8  3DB2     ADDWFC 0x32, F
140:           	temp.n = _Umul8_16(HIGHBYTE(a), HIGHBYTE(b));
06D9  0822     MOVF 0x22, W
06DA  00F9     MOVWF fp
06DB  0879     MOVF fp, W
06DC  00F0     MOVWF __pcstackCOMMON
06DD  0826     MOVF 0x26, W
06DE  318C     MOVLP 0xC
06DF  24BD     CALL 0x4BD
06E0  3185     MOVLP 0x5
06E1  0871     MOVF counter, W
06E2  0140     MOVLB 0x0
06E3  00B4     MOVWF 0x34
06E4  0870     MOVF __pcstackCOMMON, W
06E5  00B3     MOVWF temp
141:           	prod.i += (((unsigned long)temp.n) << 8);
06E6  0833     MOVF temp, W
06E7  00F9     MOVWF fp
06E8  0834     MOVF 0x34, W
06E9  00FA     MOVWF 0x7A
06EA  01FB     CLRF 0x7B
06EB  01FC     CLRF 0x7C
06EC  3008     MOVLW 0x8
06ED  35F9     LSLF fp, F
06EE  0DFA     RLF 0x7A, F
06EF  0DFB     RLF 0x7B, F
06F0  0DFC     RLF 0x7C, F
06F1  0B89     DECFSZ WREG, F
06F2  2EED     GOTO 0x6ED
06F3  0879     MOVF fp, W
06F4  07AF     ADDWF prod, F
06F5  087A     MOVF 0x7A, W
06F6  3DB0     ADDWFC d, F
06F7  087B     MOVF 0x7B, W
06F8  3DB1     ADDWFC 0x31, F
06F9  087C     MOVF 0x7C, W
06FA  3DB2     ADDWFC 0x32, F
142:           #endif
143:           
144:           	// first add the overflow bit from the lower half to the upper half
145:           	prod.i += (grs >> 24);
06FB  0829     MOVF grs, W
06FC  00F9     MOVWF fp
06FD  082A     MOVF 0x2A, W
06FE  00FA     MOVWF 0x7A
06FF  082B     MOVF cp, W
0700  00FB     MOVWF 0x7B
0701  082C     MOVF 0x2C, W
0702  00FC     MOVWF 0x7C
0703  3018     MOVLW 0x18
0704  36FC     LSRF 0x7C, F
0705  0CFB     RRF 0x7B, F
0706  0CFA     RRF 0x7A, F
0707  0CF9     RRF fp, F
0708  0B89     DECFSZ WREG, F
0709  2F04     GOTO 0x704
070A  0879     MOVF fp, W
070B  07AF     ADDWF prod, F
070C  087A     MOVF 0x7A, W
070D  3DB0     ADDWFC d, F
070E  087B     MOVF 0x7B, W
070F  3DB1     ADDWFC 0x31, F
0710  087C     MOVF 0x7C, W
0711  3DB2     ADDWFC 0x32, F
146:           	grs <<= 8;
0712  3008     MOVLW 0x8
0713  35A9     LSLF grs, F
0714  0DAA     RLF 0x2A, F
0715  0DAB     RLF cp, F
0716  0DAC     RLF 0x2C, F
0717  0B89     DECFSZ WREG, F
0718  2F13     GOTO 0x713
147:           
148:           	/* Add source exponent, minus (bias - 1) */
149:           	temp.i = bexp + aexp - 126;
0719  082E     MOVF bexp, W
071A  072D     ADDWF aexp, W
071B  00F9     MOVWF fp
071C  01FA     CLRF 0x7A
071D  0DFA     RLF 0x7A, F
071E  0879     MOVF fp, W
071F  3E82     ADDLW 0x82
0720  00B3     MOVWF temp
0721  30FF     MOVLW 0xFF
0722  3D7A     ADDWFC 0x7A, W
0723  00B4     MOVWF 0x34
150:           
151:           	/* Renormalize  */
152:           	while (!(prod.i & ((int32_t) 1 << SPFRCB))) {
0724  2F3C     GOTO 0x73C
073C  1FB1     BTFSS 0x31, 0x7
073D  2F3F     GOTO 0x73F
073E  2F40     GOTO 0x740
073F  2F25     GOTO 0x725
153:           		prod.i <<= 1;
0725  3001     MOVLW 0x1
0726  35AF     LSLF prod, F
0727  0DB0     RLF d, F
0728  0DB1     RLF 0x31, F
0729  0DB2     RLF 0x32, F
072A  0B89     DECFSZ WREG, F
072B  2F26     GOTO 0x726
154:           		if (grs & 0x80000000) {
072C  1FAC     BTFSS 0x2C, 0x7
072D  2F2F     GOTO 0x72F
072E  2F30     GOTO 0x730
072F  2F31     GOTO 0x731
155:           			prod.i |= 0x1;
0730  142F     BSF prod, 0x0
156:           		}
157:           		grs <<= 1;
0731  3001     MOVLW 0x1
0732  35A9     LSLF grs, F
0733  0DAA     RLF 0x2A, F
0734  0DAB     RLF cp, F
0735  0DAC     RLF 0x2C, F
0736  0B89     DECFSZ WREG, F
0737  2F32     GOTO 0x732
158:           		--temp.i;
0738  30FF     MOVLW 0xFF
0739  07B3     ADDWF temp, F
073A  30FF     MOVLW 0xFF
073B  3DB4     ADDWFC 0x34, F
159:           	}
160:           
161:           	/* Round, check overflow, underflow */
162:           	// reuse aexp as round up flag
163:           	aexp = 0;
0740  01AD     CLRF aexp
164:           	if (grs & 0x80000000) {
0741  1FAC     BTFSS 0x2C, 0x7
0742  2F44     GOTO 0x744
0743  2F45     GOTO 0x745
0744  2F61     GOTO 0x761
165:           		if (grs & 0x7FFFFFFF) {
0745  30FF     MOVLW 0xFF
0746  0529     ANDWF grs, W
0747  00F9     MOVWF fp
0748  30FF     MOVLW 0xFF
0749  052A     ANDWF 0x2A, W
074A  00FA     MOVWF 0x7A
074B  30FF     MOVLW 0xFF
074C  052B     ANDWF cp, W
074D  00FB     MOVWF 0x7B
074E  307F     MOVLW 0x7F
074F  052C     ANDWF 0x2C, W
0750  00FC     MOVWF 0x7C
0751  087C     MOVF 0x7C, W
0752  047B     IORWF 0x7B, W
0753  047A     IORWF 0x7A, W
0754  0479     IORWF fp, W
0755  1903     BTFSC STATUS, 0x2
0756  2F58     GOTO 0x758
0757  2F59     GOTO 0x759
0758  2F5C     GOTO 0x75C
166:           			aexp = 1;
0759  01AD     CLRF aexp
075A  0AAD     INCF aexp, F
167:           		}
075B  2F61     GOTO 0x761
168:           		else {
169:           			if (prod.i & 1) {
075C  1C2F     BTFSS prod, 0x0
075D  2F5F     GOTO 0x75F
075E  2F60     GOTO 0x760
075F  2F61     GOTO 0x761
0760  2F59     GOTO 0x759
170:           				aexp = 1;
171:           			}
172:           		}
173:           	}
174:           	if (aexp) {
0761  082D     MOVF aexp, W
0762  1903     BTFSC STATUS, 0x2
0763  2F65     GOTO 0x765
0764  2F66     GOTO 0x766
0765  2F8E     GOTO 0x78E
175:           		++prod.i;
0766  3001     MOVLW 0x1
0767  07AF     ADDWF prod, F
0768  3000     MOVLW 0x0
0769  3DB0     ADDWFC d, F
076A  3000     MOVLW 0x0
076B  3DB1     ADDWFC 0x31, F
076C  3000     MOVLW 0x0
076D  3DB2     ADDWFC 0x32, F
176:           		if (prod.i & ((int32_t) 1 << (SPFRCB + 1))) {
076E  1C32     BTFSS 0x32, 0x0
076F  2F71     GOTO 0x771
0770  2F72     GOTO 0x772
0771  2F8E     GOTO 0x78E
177:           			prod.i = prod.i >> 1;
0772  082F     MOVF prod, W
0773  00F9     MOVWF fp
0774  0830     MOVF d, W
0775  00FA     MOVWF 0x7A
0776  0831     MOVF 0x31, W
0777  00FB     MOVWF 0x7B
0778  0832     MOVF 0x32, W
0779  00FC     MOVWF 0x7C
077A  3001     MOVLW 0x1
077B  00FD     MOVWF 0x7D
077C  37FC     ASRF 0x7C, F
077D  0CFB     RRF 0x7B, F
077E  0CFA     RRF 0x7A, F
077F  0CF9     RRF fp, F
0780  0BFD     DECFSZ 0x7D, F
0781  2F7C     GOTO 0x77C
0782  087C     MOVF 0x7C, W
0783  00B2     MOVWF 0x32
0784  087B     MOVF 0x7B, W
0785  00B1     MOVWF 0x31
0786  087A     MOVF 0x7A, W
0787  00B0     MOVWF d
0788  0879     MOVF fp, W
0789  00AF     MOVWF prod
178:           			++temp.i;
078A  3001     MOVLW 0x1
078B  07B3     ADDWF temp, F
078C  3000     MOVLW 0x0
078D  3DB4     ADDWFC 0x34, F
179:           		}
180:           	}
181:           
182:           	/* Overflow ? Return infinity */
183:           	if (!(temp.i < SPEXPM)) {
078E  0834     MOVF 0x34, W
078F  3A80     XORLW 0x80
0790  00F9     MOVWF fp
0791  3080     MOVLW 0x80
0792  0279     SUBWF fp, W
0793  1D03     BTFSS STATUS, 0x2
0794  2F97     GOTO 0x797
0795  30FF     MOVLW 0xFF
0796  0233     SUBWF temp, W
0797  1C03     BTFSS STATUS, 0x0
0798  2F9A     GOTO 0x79A
0799  2F9B     GOTO 0x79B
079A  2FA5     GOTO 0x7A5
184:           		prod.i = 0x7F800000;
079B  307F     MOVLW 0x7F
079C  0140     MOVLB 0x0
079D  00B2     MOVWF 0x32
079E  3080     MOVLW 0x80
079F  00B1     MOVWF 0x31
07A0  3000     MOVLW 0x0
07A1  00B0     MOVWF d
07A2  3000     MOVLW 0x0
07A3  00AF     MOVWF prod
185:           	}
07A4  2FD4     GOTO 0x7D4
186:           	/* Underflow ? Flush to zero */
187:           	else if (!(0 < temp.i)) {
07A5  0140     MOVLB 0x0
07A6  0834     MOVF 0x34, W
07A7  3A80     XORLW 0x80
07A8  00F9     MOVWF fp
07A9  3080     MOVLW 0x80
07AA  0279     SUBWF fp, W
07AB  1D03     BTFSS STATUS, 0x2
07AC  2FAF     GOTO 0x7AF
07AD  3001     MOVLW 0x1
07AE  0233     SUBWF temp, W
07AF  1803     BTFSC STATUS, 0x0
07B0  2FB2     GOTO 0x7B2
07B1  2FB3     GOTO 0x7B3
07B2  2FBE     GOTO 0x7BE
188:           		prod.i = 0;
07B3  3000     MOVLW 0x0
07B4  0140     MOVLB 0x0
07B5  00B2     MOVWF 0x32
07B6  3000     MOVLW 0x0
07B7  00B1     MOVWF 0x31
07B8  3000     MOVLW 0x0
07B9  00B0     MOVWF d
07BA  3000     MOVLW 0x0
07BB  00AF     MOVWF prod
189:                           // no negative 0 for now
190:                           sign=0;
07BC  01A8     CLRF dividend
191:           	}
07BD  2FD4     GOTO 0x7D4
192:           	else {
193:           		/* Pack and return result */
194:           		bexp = temp.i;	// it fits in 8 bits !
07BE  0140     MOVLB 0x0
07BF  0833     MOVF temp, W
07C0  00F9     MOVWF fp
07C1  0879     MOVF fp, W
07C2  00AE     MOVWF bexp
195:           		prod.i &= SPFRCM;	// trim away the leading 1
07C3  30FF     MOVLW 0xFF
07C4  05AF     ANDWF prod, F
07C5  30FF     MOVLW 0xFF
07C6  05B0     ANDWF d, F
07C7  307F     MOVLW 0x7F
07C8  05B1     ANDWF 0x31, F
07C9  3000     MOVLW 0x0
07CA  05B2     ANDWF 0x32, F
196:           		if (bexp & 0x1) {
07CB  1C2E     BTFSS bexp, 0x0
07CC  2FCE     GOTO 0x7CE
07CD  2FCF     GOTO 0x7CF
07CE  2FD0     GOTO 0x7D0
197:           			prod.fAsBytes.c |= 0x80;
07CF  17B1     BSF 0x31, 0x7
198:           		}
199:           		prod.fAsBytes.d = bexp >> 1;
07D0  362E     LSRF bexp, W
07D1  00F9     MOVWF fp
07D2  0879     MOVF fp, W
07D3  00B2     MOVWF 0x32
200:           	}
201:           	prod.fAsBytes.d |= sign;
07D4  0828     MOVF dividend, W
07D5  00F9     MOVWF fp
07D6  0879     MOVF fp, W
07D7  04B2     IORWF 0x32, F
202:           
203:           	return prod.f;
07D8  0832     MOVF 0x32, W
07D9  00A3     MOVWF s
07DA  0831     MOVF 0x31, W
07DB  00A2     MOVWF 0x22
07DC  0830     MOVF d, W
07DD  00A1     MOVWF i
07DE  082F     MOVF prod, W
07DF  00A0     MOVWF __pcstackBANK0
204:           
205:           }
07E0  0008     RETURN
206:           
---  /Applications/microchip/xc8/v2.20/pic/sources/c99/common/printf.c  ---------------------------------
1:             #include <stdio.h>
2:             #include <stdarg.h>
3:             #include "stdio_impl.h"
4:             
5:             int printf(const char *restrict fmt, ...)
6:             {
7:             	int ret;
8:             	va_list ap;
9:             	va_start(ap, fmt);
0C06  306A     MOVLW 0x6A
0C07  0140     MOVLB 0x0
0C08  00EC     MOVWF 0x6C
0C09  086C     MOVF 0x6C, W
0C0A  00EF     MOVWF ap
10:            	ret = vfprintf(stdout, fmt, ap);
0C0B  0869     MOVF 0x69, W
0C0C  00E1     MOVWF 0x61
0C0D  0868     MOVF fmt, W
0C0E  00E0     MOVWF fmt
0C0F  306F     MOVLW 0x6F
0C10  00EC     MOVWF 0x6C
0C11  086C     MOVF 0x6C, W
0C12  00E2     MOVWF ap
0C13  3000     MOVLW 0x0
0C14  318D     MOVLP 0xD
0C15  252E     CALL 0x52E
0C16  318C     MOVLP 0xC
11:            	va_end(ap);
12:            	return ret;
13:            }
0C17  0008     RETURN
---  /Applications/microchip/xc8/v2.20/pic/sources/c99/common/nf_fputs.c  -------------------------------
1:             /* "No file system" fputs */
2:             #include <stdio.h>
3:             
4:             #include "stdio_impl.h"
5:             
6:             #ifdef STDIO_NO_FILE_IO
7:             
8:             int fputs(const char *s, FILE *fp)
0D05  0140     MOVLB 0x0
0D06  00A3     MOVWF s
9:             {
10:                char c;
11:                int i;
12:            
13:                i = 0;
0D07  01A1     CLRF i
0D08  01A2     CLRF 0x22
14:                while ((c = *(s + i))) {
0D09  2D1D     GOTO 0x51D
0D1D  0821     MOVF i, W
0D1E  0723     ADDWF s, W
0D1F  00FA     MOVWF 0x7A
0D20  087A     MOVF 0x7A, W
0D21  0086     MOVWF FSR1
0D22  3001     MOVLW 0x1
0D23  0087     MOVWF FSR1H
0D24  0801     MOVF INDF1, W
0D25  00FB     MOVWF 0x7B
0D26  087B     MOVF 0x7B, W
0D27  00A0     MOVWF __pcstackBANK0
0D28  0820     MOVF __pcstackBANK0, W
0D29  1D03     BTFSS STATUS, 0x2
0D2A  2D2C     GOTO 0x52C
0D2B  2D2D     GOTO 0x52D
0D2C  2D0A     GOTO 0x50A
15:            	fputc(c,fp);
0D0A  0820     MOVF __pcstackBANK0, W
0D0B  00FA     MOVWF 0x7A
0D0C  01FB     CLRF 0x7B
0D0D  087A     MOVF 0x7A, W
0D0E  00F1     MOVWF counter
0D0F  087B     MOVF 0x7B, W
0D10  00F2     MOVWF sign
0D11  0879     MOVF fp, W
0D12  00FC     MOVWF 0x7C
0D13  087C     MOVF 0x7C, W
0D14  00F3     MOVWF a
0D15  318D     MOVLP 0xD
0D16  255F     CALL 0x55F
0D17  318D     MOVLP 0xD
16:                    ++i;
0D18  3001     MOVLW 0x1
0D19  0140     MOVLB 0x0
0D1A  07A1     ADDWF i, F
0D1B  3000     MOVLW 0x0
0D1C  3DA2     ADDWFC 0x22, F
17:                }
18:                return i;
19:            }
0D2D  0008     RETURN
20:            
21:            #endif
---  /Applications/microchip/xc8/v2.20/pic/sources/c99/common/nf_fputc.c  -------------------------------
1:             #include <stdio.h>
2:             
3:             #include "stdio_impl.h"
4:             
5:             #ifdef STDIO_NO_FILE_IO
6:             /* "No file system" fputc */
7:             
8:             int fputc(int c, FILE *fp)
9:             {
10:                extern void putch(char);
11:            
12:                if ((fp == stdout) || (fp == stderr)) {
0D5F  0873     MOVF a, W
0D60  1903     BTFSC STATUS, 0x2
0D61  2D63     GOTO 0x563
0D62  2D64     GOTO 0x564
0D63  2D69     GOTO 0x569
0D64  0873     MOVF a, W
0D65  1D03     BTFSS STATUS, 0x2
0D66  2D68     GOTO 0x568
0D67  2D69     GOTO 0x569
0D68  2D6E     GOTO 0x56E
13:                    putch(c);
0D69  0871     MOVF counter, W
0D6A  318B     MOVLP 0xB
0D6B  23EE     CALL 0x3EE
0D6C  318D     MOVLP 0xD
14:                } else {
0D6D  2D9D     GOTO 0x59D
15:            	if((fp->limit == 0) || (fp->count < fp->limit)) {
0D6E  0873     MOVF a, W
0D6F  3E03     ADDLW 0x3
0D70  0086     MOVWF FSR1
0D71  0187     CLRF FSR1H
0D72  0016     MOVIW FSR1++
0D73  0401     IORWF INDF1, W
0D74  1903     BTFSC STATUS, 0x2
0D75  2D77     GOTO 0x577
0D76  2D78     GOTO 0x578
0D77  2D95     GOTO 0x595
0D78  0873     MOVF a, W
0D79  3E03     ADDLW 0x3
0D7A  0086     MOVWF FSR1
0D7B  0187     CLRF FSR1H
0D7C  3F40     MOVIW [0]FSR1
0D7D  00F4     MOVWF multiplicand
0D7E  3F41     MOVIW [1]FSR1
0D7F  00F5     MOVWF 0x75
0D80  0A73     INCF a, W
0D81  0086     MOVWF FSR1
0D82  0187     CLRF FSR1H
0D83  3F40     MOVIW [0]FSR1
0D84  00F6     MOVWF b
0D85  3F41     MOVIW [1]FSR1
0D86  00F7     MOVWF 0x77
0D87  0877     MOVF 0x77, W
0D88  3A80     XORLW 0x80
0D89  00F8     MOVWF product
0D8A  0875     MOVF 0x75, W
0D8B  3A80     XORLW 0x80
0D8C  0278     SUBWF product, W
0D8D  1D03     BTFSS STATUS, 0x2
0D8E  2D91     GOTO 0x591
0D8F  0874     MOVF multiplicand, W
0D90  0276     SUBWF b, W
0D91  1803     BTFSC STATUS, 0x0
0D92  2D94     GOTO 0x594
0D93  2D95     GOTO 0x595
0D94  2D9D     GOTO 0x59D
16:            	        fp->buffer[fp->count] = (char)c;
17:            		++fp->count;
0D95  0A73     INCF a, W
0D96  0086     MOVWF FSR1
0D97  0187     CLRF FSR1H
0D98  3001     MOVLW 0x1
0D99  0781     ADDWF INDF1, F
0D9A  3141     ADDFSR 1, 1
0D9B  1803     BTFSC STATUS, 0x0
0D9C  0A81     INCF INDF1, F
18:            	}
19:                }
20:                return (unsigned char)c;
21:            }
0D9D  0008     RETURN
22:            
23:            #endif
---  /Applications/microchip/xc8/v2.20/pic/sources/c99/common/doprnt.c  ---------------------------------
1:             /* vfprintf with configurable support for format conversions */
2:             /* This code is specifically for XC8 */
3:             #include <ctype.h>
4:             #include <math.h>
5:             #include <stdarg.h>
6:             #include <stddef.h>
7:             #include <stdint.h>
8:             #include <stdio.h>
9:             #include <stdlib.h>
10:            #include <string.h>
11:            #include <inline.h>
12:            
13:            /* Configuration options */
14:            #ifdef _VFPF_ALL
15:            #define _VFPF_CONVERT
16:            #define _VFPF_FLAGS
17:            #define _VFPF_WIDTH
18:            #define _VFPF_PRECISION
19:            
20:            #define _VFPF_HH
21:            #define _VFPF_H
22:            #define _VFPF_L
23:            #define _VFPF_LL
24:            #define _VFPF_J
25:            #define _VFPF_T
26:            #define _VFPF_Z
27:            
28:            #define _VFPF_A
29:            #define _VFPF_C
30:            #define _VFPF_D
31:            #define _VFPF_E
32:            #define _VFPF_F
33:            #define _VFPF_G
34:            #define _VFPF_O
35:            #define _VFPF_N
36:            #define _VFPF_P
37:            #define _VFPF_S
38:            #define _VFPF_U
39:            #define _VFPF_X
40:            #endif
41:            
42:            #ifndef ARRAYSIZE
43:            #define ARRAYSIZE(a)	(sizeof(a)/sizeof(a[0]))
44:            #endif
45:            #ifndef CSTRLEN
46:            #define CSTRLEN(s)	(ARRAYSIZE(s)-1)
47:            #endif
48:            
49:            /* Flags, precision, width */
50:            #define MINUS_FLAG (1 << 0)
51:            #define ZERO_FLAG (1 << 1)
52:            #define PLUS_FLAG (1 << 2)
53:            #define SPACE_FLAG (1 << 3)
54:            #define POUND_FLAG (1 << 4)
55:            static int flags, prec, width;
56:            
57:            #ifdef _VFPF_CONVERT
58:            /* This buffer must be at least 32 bytes long for this code to be safe */
59:            /* Output that would exceed buffer capacity is truncated */
60:            #if defined(_VFPF_A) || defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
61:            #define DBLEN 80
62:            #define EXPLEN 5
63:            #else
64:            #define DBLEN 32
65:            #endif
66:            static char dbuf[DBLEN];
67:            
68:            /* Character count */
69:            static int nout;
70:            
71:            /* Output the string in dbuf, padded on the left or right */
72:            static _INLINE int pad(FILE *fp, char *buf, int p)
0DE3  0140     MOVLB 0x0
73:            {
74:                int i, w;
75:            
76:                /* Left justify ? Put out string */
77:                if (flags & MINUS_FLAG) {
0DE5  0141     MOVLB 0x1
0DE6  1C52     BTFSS flags, 0x0
0DE7  2DE9     GOTO 0x5E9
0DE8  2DEA     GOTO 0x5EA
0DE9  2DF3     GOTO 0x5F3
78:                    fputs((const char *)buf, fp);
0DEA  0140     MOVLB 0x0
0DEB  082B     MOVF cp, W
0DEC  00FD     MOVWF 0x7D
0DED  087D     MOVF 0x7D, W
0DEE  00F9     MOVWF fp
0DEF  0824     MOVF b, W
0DF0  318D     MOVLP 0xD
0DF1  2505     CALL 0x505
0DF2  318D     MOVLP 0xD
79:                }
80:            
81:                /* Put out padding */
82:                w = (p < 0) ? 0 : p;
0DF3  0140     MOVLB 0x0
0DF4  1BA6     BTFSC 0x26, 0x7
0DF5  2DF7     GOTO 0x5F7
0DF6  2DF8     GOTO 0x5F8
0DF7  2DFD     GOTO 0x5FD
0DF8  0826     MOVF 0x26, W
0DF9  00AA     MOVWF 0x2A
0DFA  0825     MOVF p, W
0DFB  00A9     MOVWF grs
0DFC  2DFF     GOTO 0x5FF
0DFD  01A9     CLRF grs
0DFE  01AA     CLRF 0x2A
83:                i = 0;
0DFF  01A7     CLRF i
0E00  01A8     CLRF dividend
84:                while (i < w) {
0E01  2E13     GOTO 0x613
0E13  0828     MOVF dividend, W
0E14  3A80     XORLW 0x80
0E15  00FD     MOVWF 0x7D
0E16  082A     MOVF 0x2A, W
0E17  3A80     XORLW 0x80
0E18  027D     SUBWF 0x7D, W
0E19  1D03     BTFSS STATUS, 0x2
0E1A  2E1D     GOTO 0x61D
0E1B  0829     MOVF grs, W
0E1C  0227     SUBWF i, W
0E1D  1C03     BTFSS STATUS, 0x0
0E1E  2E20     GOTO 0x620
0E1F  2E21     GOTO 0x621
0E20  2E02     GOTO 0x602
85:                    fputc(' ', fp);
0E02  3020     MOVLW 0x20
0E03  00F1     MOVWF counter
0E04  3000     MOVLW 0x0
0E05  00F2     MOVWF sign
0E06  0140     MOVLB 0x0
0E07  082B     MOVF cp, W
0E08  00FD     MOVWF 0x7D
0E09  087D     MOVF 0x7D, W
0E0A  00F3     MOVWF a
0E0B  318D     MOVLP 0xD
0E0C  255F     CALL 0x55F
0E0D  318D     MOVLP 0xD
86:                    ++i;
0E0E  3001     MOVLW 0x1
0E0F  0140     MOVLB 0x0
0E10  07A7     ADDWF i, F
0E11  3000     MOVLW 0x0
0E12  3DA8     ADDWFC dividend, F
87:                }
88:            
89:                /* Right justify ? Put out string */
90:                if (!(flags & MINUS_FLAG)) {
0E21  0141     MOVLB 0x1
0E22  1852     BTFSC flags, 0x0
0E23  2E25     GOTO 0x625
0E24  2E26     GOTO 0x626
0E25  2E2F     GOTO 0x62F
91:                    fputs((const char *)buf, fp);
0E26  0140     MOVLB 0x0
0E27  082B     MOVF cp, W
0E28  00FD     MOVWF 0x7D
0E29  087D     MOVF 0x7D, W
0E2A  00F9     MOVWF fp
0E2B  0824     MOVF b, W
0E2C  318D     MOVLP 0xD
0E2D  2505     CALL 0x505
0E2E  318D     MOVLP 0xD
92:                }
93:            
94:                return strlen(buf) + w;
0E2F  0140     MOVLB 0x0
0E30  0824     MOVF b, W
0E31  00F0     MOVWF __pcstackCOMMON
0E32  3001     MOVLW 0x1
0E33  00F1     MOVWF counter
0E34  318C     MOVLP 0xC
0E35  246B     CALL 0x46B
0E36  318D     MOVLP 0xD
0E37  0140     MOVLB 0x0
0E38  0829     MOVF grs, W
0E39  0770     ADDWF __pcstackCOMMON, W
0E3A  00A4     MOVWF b
0E3B  082A     MOVF 0x2A, W
0E3C  3D71     ADDWFC counter, W
0E3D  00A5     MOVWF p
95:            }
0E3E  0008     RETURN
96:            #endif
97:            
98:            #ifdef _VFPF_A
99:            static _INLINE int atoa(FILE *fp, long double f, char c)
100:           {
101:               char mode, nmode;
102:               int d, e, i, m, n, ne, p, pp, sign, t, w;
103:               long double g, h, l, ou, u;
104:           
105:               /* Record sign, get absolute value */
106:               sign = 0;
107:               g = f;
108:               if (g < 0.0) {
109:                   sign = 1;
110:                   g = -g;
111:               }
112:           
113:               /* Print sign, prefix */
114:               n = 0;
115:               w = width;
116:               if (sign || (flags & PLUS_FLAG)) {
117:                   dbuf[n] = sign ? '-' : '+';
118:                   ++n;
119:                   --w;
120:               }
121:               dbuf[n++] = '0';
122:               dbuf[n++] = isupper((int)c) ? 'X' : 'x';
123:           
124:               /* Catch infinities, NaNs here */
125:               if (isinf(g)) {
126:                   if (isupper((int)c)) {
127:                       strcpy(&dbuf[n], "INF");
128:                   } else {
129:                       strcpy(&dbuf[n], "inf");
130:                   }
131:                   w -= CSTRLEN("inf");
132:                   return pad(fp, &dbuf[0], w);
133:               }
134:               if (isnan(g)) {
135:                   if (isupper((int)c)) {
136:                       strcpy(&dbuf[n], "NAN");
137:                   } else {
138:                       strcpy(&dbuf[n], "nan");
139:                   }
140:                   w -= CSTRLEN("inf");
141:                   return pad(fp, &dbuf[0], w);
142:               }
143:           
144:               /* First find the largest power of 2 not larger than number to print */
145:               u = 1.0;
146:               e = 0;
147:               if (!(g == 0.0)) {
148:                   while (!(g < (u*2.0))) {
149:                       u = u*2.0;
150:                       ++e;
151:                   }
152:                   while (g < u) {
153:                       u = u/2.0;
154:                       --e;
155:                   }
156:               }
157:           
158:               /* Get precision */
159:               p = (prec < 0) ? 6 : prec;
160:           
161:               /* Hex places, total */
162:               m = p + 1;
163:           
164:               /* Go through the conversion once to get to the rounding step */
165:               i = 0;
166:               h = g;
167:               ou = u;
168:               while (i < m) {
169:                   l = floor(h/u);
170:                   d = (int)l;
171:                   h -= l*u;
172:                   u = u/16.0;
173:                   ++i;
174:               }
175:               
176:               /* Remainder >= halfway ? */
177:               l = u*8.0;
178:               if (h < l) {
179:                   l = 0.0;
180:               } else {
181:                   /* On tie choose even number */
182:                   if ((h == l) && !(d % 2)) {
183:                       l = 0.0;
184:                   }
185:               }
186:           
187:               /* Round */
188:               h = g + l;
189:               
190:               /* Convert again, after rounding */
191:               u = ou;
192:               ne = 0;
193:               pp = 0;
194:               t = 0;
195:               i = 0;
196:               while ((i < m) && (n < (DBLEN - EXPLEN))) {
197:                   l = floor(h/u);
198:                   d = (int)l;
199:                   if (!(flags & POUND_FLAG) && !d && (ne < 0)) {
200:                       ++t;
201:                   } else {
202:                       if (!pp && (ne < 0)) {
203:                           dbuf[n++] = '.';
204:                           --w;
205:                           pp = 1;
206:                       }
207:                       while (t) {
208:                           dbuf[n++] = '0';
209:                           --w;
210:                           --t;
211:                       }
212:                       d = (d < 10) ? '0' + d : 'a' + (d - 10);
213:                       if (isupper((int)c) && isalpha(d)) {
214:                           d = toupper(d);
215:                       }
216:                       dbuf[n++] = d;
217:                       --w;
218:                   }
219:                   h -= l*u;
220:                   u = u/16.0;
221:                   --ne;
222:                   ++i;
223:               }
224:               if (!pp && (flags & POUND_FLAG)) {
225:                   dbuf[n++] = '.';
226:               }
227:               dbuf[n] = '\0';
228:           
229:               /* Convert exponent */
230:               i = sizeof(dbuf) - 1;
231:               dbuf[i] = '\0';
232:               sign = 0;
233:               if (e < 0) {
234:                   sign = 1;
235:                   e = -e;
236:               }
237:               p = 1;
238:               while (e || (0 < p)) {
239:                   --i;
240:                   dbuf[i] = '0' + (e % 10);
241:                   e = e / 10;
242:                   --p;
243:                   --w;
244:               }
245:               --i;
246:               dbuf[i] = sign ? '-' : '+';
247:               --w;
248:               --i;
249:               dbuf[i] = isupper((int)c) ? 'P' : 'p';
250:               --w;
251:               strcpy(&dbuf[n], &dbuf[i]);
252:           
253:               /* Put out padded string */
254:               return pad(fp, &dbuf[0], w);
255:           }
256:           #endif
257:           
258:           #ifdef _VFPF_C
259:           static _INLINE int ctoa(FILE *fp, char c)
260:           {
261:               int l, w;
262:           
263:               /* Get width */
264:               w = width ? width - 1 : width;
265:           
266:               /* Put out padded string */
267:               dbuf[0] = c;
268:               dbuf[1] = '\0';
269:               return pad(fp, &dbuf[0], w);
270:           }
271:           #endif
272:           
273:           #ifdef _VFPF_D
274:           static _INLINE int dtoa(FILE *fp, long long d)
0248  0140     MOVLB 0x0
275:           {
276:               int i, p, s, w;
277:               long long n;
278:           
279:               /* Record sign, get absolute value */
280:               n = d;
024A  0830     MOVF d, W
024B  00C4     MOVWF n
024C  0831     MOVF 0x31, W
024D  00C5     MOVWF 0x45
024E  0832     MOVF 0x32, W
024F  00C6     MOVWF 0x46
0250  0833     MOVF temp, W
0251  00C7     MOVWF 0x47
0252  0834     MOVF 0x34, W
0253  00C8     MOVWF 0x48
0254  0835     MOVF 0x35, W
0255  00C9     MOVWF 0x49
0256  0836     MOVF 0x36, W
0257  00CA     MOVWF 0x4A
0258  0837     MOVF 0x37, W
0259  00CB     MOVWF 0x4B
281:               s = n < 0 ? 1 : 0;
025A  3044     MOVLW 0x44
025B  0086     MOVWF FSR1
025C  3000     MOVLW 0x0
025D  0087     MOVWF FSR1H
025E  3F47     MOVIW [7]FSR1
025F  00B8     MOVWF 0x38
0260  1BB8     BTFSC 0x38, 0x7
0261  2A63     GOTO 0x263
0262  2A65     GOTO 0x265
0263  3001     MOVLW 0x1
0264  2A66     GOTO 0x266
0265  3000     MOVLW 0x0
0266  0140     MOVLB 0x0
0267  00B9     MOVWF 0x39
0268  01BA     CLRF 0x3A
0269  0839     MOVF 0x39, W
026A  00C2     MOVWF s
026B  083A     MOVF 0x3A, W
026C  00C3     MOVWF 0x43
282:               if (s) {
026D  0842     MOVF s, W
026E  0443     IORWF 0x43, W
026F  1903     BTFSC STATUS, 0x2
0270  2A72     GOTO 0x272
0271  2A73     GOTO 0x273
0272  2A91     GOTO 0x291
283:                   n = -n;
0273  09C4     COMF n, F
0274  09C5     COMF 0x45, F
0275  09C6     COMF 0x46, F
0276  09C7     COMF 0x47, F
0277  09C8     COMF 0x48, F
0278  09C9     COMF 0x49, F
0279  09CA     COMF 0x4A, F
027A  09CB     COMF 0x4B, F
027B  0AC4     INCF n, F
027C  1D03     BTFSS STATUS, 0x2
027D  2A91     GOTO 0x291
027E  0AC5     INCF 0x45, F
027F  1D03     BTFSS STATUS, 0x2
0280  2A91     GOTO 0x291
0281  0AC6     INCF 0x46, F
0282  1D03     BTFSS STATUS, 0x2
0283  2A91     GOTO 0x291
0284  0AC7     INCF 0x47, F
0285  1D03     BTFSS STATUS, 0x2
0286  2A91     GOTO 0x291
0287  0AC8     INCF 0x48, F
0288  1D03     BTFSS STATUS, 0x2
0289  2A91     GOTO 0x291
028A  0AC9     INCF 0x49, F
028B  1D03     BTFSS STATUS, 0x2
028C  2A91     GOTO 0x291
028D  0ACA     INCF 0x4A, F
028E  1D03     BTFSS STATUS, 0x2
028F  2A91     GOTO 0x291
0290  0ACB     INCF 0x4B, F
284:               }
285:           
286:               /* Adjust flags, precision, width */
287:               if (!(prec < 0)) {
0291  0141     MOVLB 0x1
0292  1BD1     BTFSC 0xD1, 0x7
0293  2A95     GOTO 0x295
0294  2A96     GOTO 0x296
0295  2A9A     GOTO 0x29A
288:                   flags &= ~ZERO_FLAG;
0296  30FD     MOVLW 0xFD
0297  05D2     ANDWF flags, F
0298  30FF     MOVLW 0xFF
0299  05D3     ANDWF 0xD3, F
289:               }
290:               p = (0 < prec) ? prec : 1;
029A  0851     MOVF 0xD1, W
029B  3A80     XORLW 0x80
029C  0140     MOVLB 0x0
029D  00B8     MOVWF 0x38
029E  3080     MOVLW 0x80
029F  0238     SUBWF 0x38, W
02A0  1D03     BTFSS STATUS, 0x2
02A1  2AA5     GOTO 0x2A5
02A2  3001     MOVLW 0x1
02A3  0141     MOVLB 0x1
02A4  0250     SUBWF prec, W
02A5  1803     BTFSC STATUS, 0x0
02A6  2AA8     GOTO 0x2A8
02A7  2AA9     GOTO 0x2A9
02A8  2AAF     GOTO 0x2AF
02A9  3001     MOVLW 0x1
02AA  0140     MOVLB 0x0
02AB  00BD     MOVWF p
02AC  3000     MOVLW 0x0
02AD  00BE     MOVWF 0x3E
02AE  2AB7     GOTO 0x2B7
02AF  0141     MOVLB 0x1
02B0  0851     MOVF 0xD1, W
02B1  0140     MOVLB 0x0
02B2  00BE     MOVWF 0x3E
02B3  0141     MOVLB 0x1
02B4  0850     MOVF prec, W
02B5  0140     MOVLB 0x0
02B6  00BD     MOVWF p
291:               w = width;
02B7  0141     MOVLB 0x1
02B8  084F     MOVF 0xCF, W
02B9  0140     MOVLB 0x0
02BA  00C1     MOVWF 0x41
02BB  0141     MOVLB 0x1
02BC  084E     MOVF width, W
02BD  0140     MOVLB 0x0
02BE  00C0     MOVWF w
292:               if (s || (flags & PLUS_FLAG)) {
02BF  0842     MOVF s, W
02C0  0443     IORWF 0x43, W
02C1  1D03     BTFSS STATUS, 0x2
02C2  2AC4     GOTO 0x2C4
02C3  2AC5     GOTO 0x2C5
02C4  2ACA     GOTO 0x2CA
02C5  0141     MOVLB 0x1
02C6  1D52     BTFSS flags, 0x2
02C7  2AC9     GOTO 0x2C9
02C8  2ACA     GOTO 0x2CA
02C9  2ACF     GOTO 0x2CF
293:                   --w;
02CA  30FF     MOVLW 0xFF
02CB  0140     MOVLB 0x0
02CC  07C0     ADDWF w, F
02CD  30FF     MOVLW 0xFF
02CE  3DC1     ADDWFC 0x41, F
294:               }
295:           
296:               /* Convert to decimal, possibly filling on the left with zeroes */
297:               i = sizeof(dbuf) - 1;
02CF  301F     MOVLW 0x1F
02D0  0140     MOVLB 0x0
02D1  00CC     MOVWF i
02D2  3000     MOVLW 0x0
02D3  00CD     MOVWF 0x4D
298:               dbuf[i] = '\0';
02D4  0142     MOVLB 0x2
02D5  01BF     CLRF 0x13F
299:               while (!(i < 1) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
02D6  2B40     GOTO 0x340
300:                   --i;
02D7  30FF     MOVLW 0xFF
02D8  0140     MOVLB 0x0
02D9  07CC     ADDWF i, F
02DA  30FF     MOVLW 0xFF
02DB  3DCD     ADDWFC 0x4D, F
301:                   dbuf[i] = '0' + abs(n % 10);
02DC  300A     MOVLW 0xA
02DD  00A0     MOVWF __pcstackBANK0
02DE  01A1     CLRF i
02DF  01A2     CLRF 0x22
02E0  01A3     CLRF s
02E1  01A4     CLRF b
02E2  01A5     CLRF p
02E3  01A6     CLRF 0x26
02E4  01A7     CLRF i
02E5  0844     MOVF n, W
02E6  00A8     MOVWF dividend
02E7  0845     MOVF 0x45, W
02E8  00A9     MOVWF grs
02E9  0846     MOVF 0x46, W
02EA  00AA     MOVWF 0x2A
02EB  0847     MOVF 0x47, W
02EC  00AB     MOVWF cp
02ED  0848     MOVF 0x48, W
02EE  00AC     MOVWF 0x2C
02EF  0849     MOVF 0x49, W
02F0  00AD     MOVWF aexp
02F1  084A     MOVF 0x4A, W
02F2  00AE     MOVWF bexp
02F3  084B     MOVF 0x4B, W
02F4  00AF     MOVWF prod
02F5  318F     MOVLP 0xF
02F6  2716     CALL 0x716
02F7  3182     MOVLP 0x2
02F8  0140     MOVLB 0x0
02F9  0821     MOVF i, W
02FA  00F4     MOVWF multiplicand
02FB  0820     MOVF __pcstackBANK0, W
02FC  00F3     MOVWF a
02FD  318C     MOVLP 0xC
02FE  2484     CALL 0x484
02FF  3182     MOVLP 0x2
0300  0873     MOVF a, W
0301  3E30     ADDLW 0x30
0302  0140     MOVLB 0x0
0303  00B8     MOVWF 0x38
0304  084C     MOVF i, W
0305  3E20     ADDLW 0x20
0306  0086     MOVWF FSR1
0307  3001     MOVLW 0x1
0308  0087     MOVWF FSR1H
0309  0838     MOVF 0x38, W
030A  0081     MOVWF INDF1
302:                   --p;
030B  30FF     MOVLW 0xFF
030C  07BD     ADDWF p, F
030D  30FF     MOVLW 0xFF
030E  3DBE     ADDWFC 0x3E, F
303:                   --w;
030F  30FF     MOVLW 0xFF
0310  07C0     ADDWF w, F
0311  30FF     MOVLW 0xFF
0312  3DC1     ADDWFC 0x41, F
304:                   n = n / 10;
0313  300A     MOVLW 0xA
0314  00A0     MOVWF __pcstackBANK0
0315  01A1     CLRF i
0316  01A2     CLRF 0x22
0317  01A3     CLRF s
0318  01A4     CLRF b
0319  01A5     CLRF p
031A  01A6     CLRF 0x26
031B  01A7     CLRF i
031C  0844     MOVF n, W
031D  00A8     MOVWF dividend
031E  0845     MOVF 0x45, W
031F  00A9     MOVWF grs
0320  0846     MOVF 0x46, W
0321  00AA     MOVWF 0x2A
0322  0847     MOVF 0x47, W
0323  00AB     MOVWF cp
0324  0848     MOVF 0x48, W
0325  00AC     MOVWF 0x2C
0326  0849     MOVF 0x49, W
0327  00AD     MOVWF aexp
0328  084A     MOVF 0x4A, W
0329  00AE     MOVWF bexp
032A  084B     MOVF 0x4B, W
032B  00AF     MOVWF prod
032C  3180     MOVLP 0x0
032D  2039     CALL 0x39
032E  3182     MOVLP 0x2
032F  0140     MOVLB 0x0
0330  0820     MOVF __pcstackBANK0, W
0331  00C4     MOVWF n
0332  0821     MOVF i, W
0333  00C5     MOVWF 0x45
0334  0822     MOVF 0x22, W
0335  00C6     MOVWF 0x46
0336  0823     MOVF s, W
0337  00C7     MOVWF 0x47
0338  0824     MOVF b, W
0339  00C8     MOVWF 0x48
033A  0825     MOVF p, W
033B  00C9     MOVWF 0x49
033C  0826     MOVF 0x26, W
033D  00CA     MOVWF 0x4A
033E  0827     MOVF i, W
033F  00CB     MOVWF 0x4B
305:               }
0340  0140     MOVLB 0x0
0341  084D     MOVF 0x4D, W
0342  3A80     XORLW 0x80
0343  00B8     MOVWF 0x38
0344  3080     MOVLW 0x80
0345  0238     SUBWF 0x38, W
0346  1D03     BTFSS STATUS, 0x2
0347  2B4A     GOTO 0x34A
0348  3001     MOVLW 0x1
0349  024C     SUBWF i, W
034A  1C03     BTFSS STATUS, 0x0
034B  2B4D     GOTO 0x34D
034C  2B4E     GOTO 0x34E
034D  2B7B     GOTO 0x37B
034E  0140     MOVLB 0x0
034F  0844     MOVF n, W
0350  0445     IORWF 0x45, W
0351  0446     IORWF 0x46, W
0352  0447     IORWF 0x47, W
0353  0448     IORWF 0x48, W
0354  0449     IORWF 0x49, W
0355  044A     IORWF 0x4A, W
0356  044B     IORWF 0x4B, W
0357  1D03     BTFSS STATUS, 0x2
0358  2B5A     GOTO 0x35A
0359  2B5B     GOTO 0x35B
035A  2AD7     GOTO 0x2D7
035B  083E     MOVF 0x3E, W
035C  3A80     XORLW 0x80
035D  00B8     MOVWF 0x38
035E  3080     MOVLW 0x80
035F  0238     SUBWF 0x38, W
0360  1D03     BTFSS STATUS, 0x2
0361  2B64     GOTO 0x364
0362  3001     MOVLW 0x1
0363  023D     SUBWF p, W
0364  1803     BTFSC STATUS, 0x0
0365  2B67     GOTO 0x367
0366  2B68     GOTO 0x368
0367  2AD7     GOTO 0x2D7
0368  0140     MOVLB 0x0
0369  0841     MOVF 0x41, W
036A  3A80     XORLW 0x80
036B  00B8     MOVWF 0x38
036C  3080     MOVLW 0x80
036D  0238     SUBWF 0x38, W
036E  1D03     BTFSS STATUS, 0x2
036F  2B72     GOTO 0x372
0370  3001     MOVLW 0x1
0371  0240     SUBWF w, W
0372  1C03     BTFSS STATUS, 0x0
0373  2B75     GOTO 0x375
0374  2B76     GOTO 0x376
0375  2B7B     GOTO 0x37B
0376  0141     MOVLB 0x1
0377  18D2     BTFSC flags, 0x1
0378  2B7A     GOTO 0x37A
0379  2B7B     GOTO 0x37B
037A  2AD7     GOTO 0x2D7
306:           
307:               /* Display sign if required */
308:               if (s || (flags & PLUS_FLAG)) {
037B  0140     MOVLB 0x0
037C  0842     MOVF s, W
037D  0443     IORWF 0x43, W
037E  1D03     BTFSS STATUS, 0x2
037F  2B81     GOTO 0x381
0380  2B82     GOTO 0x382
0381  2B87     GOTO 0x387
0382  0141     MOVLB 0x1
0383  1D52     BTFSS flags, 0x2
0384  2B86     GOTO 0x386
0385  2B87     GOTO 0x387
0386  2BA4     GOTO 0x3A4
309:                   --i;
0387  30FF     MOVLW 0xFF
0388  0140     MOVLB 0x0
0389  07CC     ADDWF i, F
038A  30FF     MOVLW 0xFF
038B  3DCD     ADDWFC 0x4D, F
310:                   dbuf[i] = s ? '-' : '+';
038C  0842     MOVF s, W
038D  0443     IORWF 0x43, W
038E  1D03     BTFSS STATUS, 0x2
038F  2B91     GOTO 0x391
0390  2B92     GOTO 0x392
0391  2B97     GOTO 0x397
0392  302B     MOVLW 0x2B
0393  00BB     MOVWF 0x3B
0394  3000     MOVLW 0x0
0395  00BC     MOVWF 0x3C
0396  2B9B     GOTO 0x39B
0397  302D     MOVLW 0x2D
0398  00BB     MOVWF 0x3B
0399  3000     MOVLW 0x0
039A  00BC     MOVWF 0x3C
039B  083B     MOVF 0x3B, W
039C  00B8     MOVWF 0x38
039D  084C     MOVF i, W
039E  3E20     ADDLW 0x20
039F  0086     MOVWF FSR1
03A0  3001     MOVLW 0x1
03A1  0087     MOVWF FSR1H
03A2  0838     MOVF 0x38, W
03A3  0081     MOVWF INDF1
311:               }
312:           
313:               /* Put out padded string */
314:               return pad(fp, &dbuf[i], w);
03A4  0140     MOVLB 0x0
03A5  084C     MOVF i, W
03A6  3E20     ADDLW 0x20
03A7  00B8     MOVWF 0x38
03A8  0838     MOVF 0x38, W
03A9  00A4     MOVWF b
03AA  0841     MOVF 0x41, W
03AB  00A6     MOVWF 0x26
03AC  0840     MOVF w, W
03AD  00A5     MOVWF p
03AE  083F     MOVF fp, W
03AF  318D     MOVLP 0xD
03B0  25E3     CALL 0x5E3
03B1  3182     MOVLP 0x2
03B2  0140     MOVLB 0x0
03B3  0825     MOVF p, W
03B4  00B1     MOVWF 0x31
03B5  0824     MOVF b, W
03B6  00B0     MOVWF d
315:           }
03B7  0008     RETURN
316:           #endif
317:           
318:           #if defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
319:           static _INLINE int efgtoa(FILE *fp, long double f, char c)
320:           {
321:               char mode, nmode;
322:               int d, e, i, m, n, ne, p, pp, sign, t, w;
323:               long double g, h, l, ou, u;
324:           
325:               /* Record sign, get absolute value */
326:               sign = 0;
327:               g = f;
328:               if (g < 0.0) {
329:                   sign = 1;
330:                   g = -g;
331:               }
332:           
333:               /* Print sign */
334:               n = 0;
335:               w = width;
336:               if (sign || (flags & PLUS_FLAG)) {
337:                   dbuf[n] = sign ? '-' : '+';
338:                   ++n;
339:                   --w;
340:               }
341:           
342:               /* Catch infinities, NaNs here */
343:               if (isinf(g)) {
344:                   if (isupper((int)c)) {
345:                       strcpy(&dbuf[n], "INF");
346:                   } else {
347:                       strcpy(&dbuf[n], "inf");
348:                   }
349:                   w -= CSTRLEN("inf");
350:                   return pad(fp, &dbuf[0], w);
351:               }
352:               if (isnan(g)) {
353:                   if (isupper((int)c)) {
354:                       strcpy(&dbuf[n], "NAN");
355:                   } else {
356:                       strcpy(&dbuf[n], "nan");
357:                   }
358:                   w -= CSTRLEN("inf");
359:                   return pad(fp, &dbuf[0], w);
360:               }
361:           
362:               /* First find the largest power of 10 not larger than number to print */
363:               u = 1.0;
364:               e = 0;
365:               if (!(g == 0.0)) {
366:                   while (!(g < (u*10.0))) {
367:                       u = u*10.0;
368:                       ++e;
369:                   }
370:                   while (g < u) {
371:                       u = u/10.0;
372:                       --e;
373:                   }
374:               }
375:           
376:               /* Get mode, precision */
377:               mode = tolower((int)c);
378:               nmode = mode;
379:               if (mode == 'g') {
380:           		if (prec == 0) {
381:           			prec = 1;
382:           		}
383:                   p = (0 < prec) ? prec : 6;
384:               } else {
385:                   p = (prec < 0) ? 6 : prec;
386:               }
387:           
388:               /* Choose e or f mode from g mode */
389:               if (mode == 'g') {
390:                   if (!(e < -4) && !((p - 1) < e)) {
391:                       nmode = 'f';
392:                   } else {
393:                       nmode = 'e';
394:                   }
395:               }
396:           
397:               /* Decimal places or significant digits */
398:               m = p;
399:               if (!(mode == 'g') || ((nmode == 'f') && (e < 0))) {
400:                   ++m;
401:               }
402:           
403:               /* Adjust starting exponent, string length for 'f' conversions */
404:               if (nmode == 'f') {
405:                   if (e < 0) {
406:                       u = 1.0;
407:                       e = 0;
408:                   }
409:                   if (!(mode == 'g')) {
410:                       m += e;
411:                   }
412:               }
413:           
414:               /* Go through the conversion once to get to the rounding step */
415:               i = 0;
416:               h = g;
417:               ou = u;
418:               while (i < m) {
419:                   l = floor(h/u);
420:                   d = (int)l;
421:                   h -= l*u;
422:                   u = u/10.0;
423:                   ++i;
424:               }
425:               
426:               /* Remainder >= halfway ? */
427:               l = u*5.0;
428:               if (h < l) {
429:                   l = 0.0;
430:               } else {
431:                   /* On tie choose even number */
432:                   if ((h == l) && !(d % 2)) {
433:                       l = 0.0;
434:                   }
435:               }
436:           
437:               /* Round */
438:               h = g + l;
439:               
440:               /* Convert again, after rounding */
441:               u = ou;
442:               ne = (nmode == 'e') ? 0 : e;
443:               pp = 0;
444:               t = 0;
445:               i = 0;
446:               while ((i < m) && (n < (DBLEN - EXPLEN))) {
447:                   l = floor(h/u);
448:                   d = (int)l;
449:                   if (!(flags & POUND_FLAG) && !d && (mode == 'g') && (ne < 0)) {
450:                       ++t;
451:                   } else {
452:                       if (!pp && (ne < 0)) {
453:                           dbuf[n++] = '.';
454:                           --w;
455:                           pp = 1;
456:                       }
457:                       while (t) {
458:                           dbuf[n++] = '0';
459:                           --w;
460:                           --t;
461:                       }
462:                       dbuf[n++] = '0' + d;
463:                       --w;
464:                   }
465:                   h -= l*u;
466:                   u = u/10.0;
467:                   --ne;
468:                   ++i;
469:               }
470:               if (!pp && (flags & POUND_FLAG)) {
471:                   dbuf[n++] = '.';
472:               }
473:               dbuf[n] = '\0';
474:           
475:               /* Convert exponent */
476:               if (nmode == 'e') {
477:                   i = sizeof(dbuf) - 1;
478:                   dbuf[i] = '\0';
479:                   sign = 0;
480:                   if (e < 0) {
481:                       sign = 1;
482:                       e = -e;
483:                   }
484:                   p = 2;
485:                   while (e || (0 < p)) {
486:                       --i;
487:                       dbuf[i] = '0' + (e % 10);
488:                       e = e / 10;
489:                       --p;
490:                       --w;
491:                   }
492:                   --i;
493:                   dbuf[i] = sign ? '-' : '+';
494:                   --w;
495:                   --i;
496:                   dbuf[i] = isupper((int)c) ? 'E' : 'e';
497:                   --w;
498:                   strcpy(&dbuf[n], &dbuf[i]);
499:               }
500:           
501:               /* Put out padded string */
502:               return pad(fp, &dbuf[0], w);
503:           }
504:           #endif
505:           
506:           #ifdef _VFPF_O
507:           static _INLINE int otoa(FILE *fp, unsigned long long d)
508:           {
509:               int i, p, t, w;
510:               unsigned long long n;
511:           
512:               /* Adjust flags, precision, width */
513:               if (!(prec < 0)) {
514:                   flags &= ~ZERO_FLAG;
515:               }
516:               p = (0 < prec) ? prec : 1;
517:               w = width;
518:           
519:               /* Convert to octal, possibly filling on the left with zeroes */
520:               n = d;
521:               i = sizeof(dbuf) - 1;
522:               dbuf[i] = '\0';
523:               t = 0;
524:               while (!(i < 1) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
525:                   --i;
526:                   t = n & 07;
527:                   dbuf[i] = '0' + t;
528:                   --p;
529:                   --w;
530:                   n = n >> 3;
531:               }
532:           
533:               /* Display prefix if required */
534:               if ((flags & POUND_FLAG) && t) {
535:                   --i;
536:                   dbuf[i] = '0';
537:                   --w;
538:               }
539:           
540:               /* Put out padded string */
541:               return pad(fp, &dbuf[i], w);
542:           }
543:           #endif
544:           
545:           #ifdef _VFPF_S
546:           static _INLINE int stoa(FILE *fp, char *s)
0E3F  0140     MOVLB 0x0
547:           {
548:               char *cp, nuls[] = "(null)";
0E41  30E3     MOVLW 0xE3
0E42  0086     MOVWF FSR1
0E43  3000     MOVLW 0x0
0E44  0087     MOVWF FSR1H
0E45  3020     MOVLW 0x20
0E46  0084     MOVWF FSR0
0E47  3000     MOVLW 0x0
0E48  0085     MOVWF FSR0H
0E49  3007     MOVLW 0x7
0E4A  00FB     MOVWF 0x7B
0E4B  0016     MOVIW FSR1++
0E4C  001A     MOVWI FSR0++
0E4D  0BFB     DECFSZ 0x7B, F
0E4E  2E4B     GOTO 0x64B
549:               int i, l, p, w;
550:           
551:               /* Check for null string */
552:               cp = s;
0E4F  087A     MOVF 0x7A, W
0E50  00AC     MOVWF 0x2C
0E51  0879     MOVF fp, W
0E52  00AB     MOVWF cp
553:               if (!cp) {
0E53  082B     MOVF cp, W
0E54  042C     IORWF 0x2C, W
0E55  1D03     BTFSS STATUS, 0x2
0E56  2E58     GOTO 0x658
0E57  2E59     GOTO 0x659
0E58  2E5D     GOTO 0x65D
554:                   cp = nuls;
0E59  3020     MOVLW 0x20
0E5A  00AB     MOVWF cp
0E5B  3000     MOVLW 0x0
0E5C  00AC     MOVWF 0x2C
555:               }
556:           
557:               /* Get length, precision, width */
558:               l = strlen(cp);
0E5D  082C     MOVF 0x2C, W
0E5E  00F1     MOVWF counter
0E5F  082B     MOVF cp, W
0E60  00F0     MOVWF __pcstackCOMMON
0E61  318C     MOVLP 0xC
0E62  246B     CALL 0x46B
0E63  318E     MOVLP 0xE
0E64  0871     MOVF counter, W
0E65  0140     MOVLB 0x0
0E66  00B1     MOVWF 0x31
0E67  0870     MOVF __pcstackCOMMON, W
0E68  00B0     MOVWF d
559:               p = prec;
0E69  0141     MOVLB 0x1
0E6A  0851     MOVF 0xD1, W
0E6B  0140     MOVLB 0x0
0E6C  00AF     MOVWF prod
0E6D  0141     MOVLB 0x1
0E6E  0850     MOVF prec, W
0E6F  0140     MOVLB 0x0
0E70  00AE     MOVWF bexp
560:               l = (!(p < 0) && (p < l)) ? p : l;
0E71  1BAF     BTFSC prod, 0x7
0E72  2E74     GOTO 0x674
0E73  2E75     GOTO 0x675
0E74  2E89     GOTO 0x689
0E75  082F     MOVF prod, W
0E76  3A80     XORLW 0x80
0E77  00FB     MOVWF 0x7B
0E78  0831     MOVF 0x31, W
0E79  3A80     XORLW 0x80
0E7A  027B     SUBWF 0x7B, W
0E7B  1D03     BTFSS STATUS, 0x2
0E7C  2E7F     GOTO 0x67F
0E7D  0830     MOVF d, W
0E7E  022E     SUBWF bexp, W
0E7F  1C03     BTFSS STATUS, 0x0
0E80  2E82     GOTO 0x682
0E81  2E83     GOTO 0x683
0E82  2E84     GOTO 0x684
0E83  2E89     GOTO 0x689
0E84  0140     MOVLB 0x0
0E85  082F     MOVF prod, W
0E86  00B1     MOVWF 0x31
0E87  082E     MOVF bexp, W
0E88  00B0     MOVWF d
561:               p = l;
0E89  0140     MOVLB 0x0
0E8A  0831     MOVF 0x31, W
0E8B  00AF     MOVWF prod
0E8C  0830     MOVF d, W
0E8D  00AE     MOVWF bexp
562:               w = width;
0E8E  0141     MOVLB 0x1
0E8F  084F     MOVF 0xCF, W
0E90  0140     MOVLB 0x0
0E91  00AA     MOVWF 0x2A
0E92  0141     MOVLB 0x1
0E93  084E     MOVF width, W
0E94  0140     MOVLB 0x0
0E95  00A9     MOVWF grs
563:           
564:               /* Right justify, pad on left ? */
565:               if (!(flags & MINUS_FLAG)) {
0E96  0141     MOVLB 0x1
0E97  1852     BTFSC flags, 0x0
0E98  2E9A     GOTO 0x69A
0E99  2E9B     GOTO 0x69B
0E9A  2EBC     GOTO 0x6BC
0E9B  2EAD     GOTO 0x6AD
566:                   while (l < w) {
0EAD  0140     MOVLB 0x0
0EAE  0831     MOVF 0x31, W
0EAF  3A80     XORLW 0x80
0EB0  00FB     MOVWF 0x7B
0EB1  082A     MOVF 0x2A, W
0EB2  3A80     XORLW 0x80
0EB3  027B     SUBWF 0x7B, W
0EB4  1D03     BTFSS STATUS, 0x2
0EB5  2EB8     GOTO 0x6B8
0EB6  0829     MOVF grs, W
0EB7  0230     SUBWF d, W
0EB8  1C03     BTFSS STATUS, 0x0
0EB9  2EBB     GOTO 0x6BB
0EBA  2EBC     GOTO 0x6BC
0EBB  2E9C     GOTO 0x69C
567:                       fputc(' ', fp);
0E9C  3020     MOVLW 0x20
0E9D  00F1     MOVWF counter
0E9E  3000     MOVLW 0x0
0E9F  00F2     MOVWF sign
0EA0  0140     MOVLB 0x0
0EA1  082D     MOVF aexp, W
0EA2  00FB     MOVWF 0x7B
0EA3  087B     MOVF 0x7B, W
0EA4  00F3     MOVWF a
0EA5  318D     MOVLP 0xD
0EA6  255F     CALL 0x55F
0EA7  318E     MOVLP 0xE
568:                       ++l;
0EA8  3001     MOVLW 0x1
0EA9  0140     MOVLB 0x0
0EAA  07B0     ADDWF d, F
0EAB  3000     MOVLW 0x0
0EAC  3DB1     ADDWFC 0x31, F
569:                   }
570:               }
571:           
572:               /* Put out string */
573:               i = 0;
0EBC  0140     MOVLB 0x0
0EBD  01A7     CLRF i
0EBE  01A8     CLRF dividend
574:               while (i < p) {
0EBF  2EDC     GOTO 0x6DC
0EDC  0828     MOVF dividend, W
0EDD  3A80     XORLW 0x80
0EDE  00FB     MOVWF 0x7B
0EDF  082F     MOVF prod, W
0EE0  3A80     XORLW 0x80
0EE1  027B     SUBWF 0x7B, W
0EE2  1D03     BTFSS STATUS, 0x2
0EE3  2EE6     GOTO 0x6E6
0EE4  082E     MOVF bexp, W
0EE5  0227     SUBWF i, W
0EE6  1C03     BTFSS STATUS, 0x0
0EE7  2EE9     GOTO 0x6E9
0EE8  2EEA     GOTO 0x6EA
0EE9  2EC0     GOTO 0x6C0
575:                   fputc(*cp, fp);
0EC0  0140     MOVLB 0x0
0EC1  082B     MOVF cp, W
0EC2  0084     MOVWF FSR0
0EC3  082C     MOVF 0x2C, W
0EC4  0085     MOVWF FSR0H
0EC5  0800     MOVF INDF0, W
0EC6  00FB     MOVWF 0x7B
0EC7  01FC     CLRF 0x7C
0EC8  087B     MOVF 0x7B, W
0EC9  00F1     MOVWF counter
0ECA  087C     MOVF 0x7C, W
0ECB  00F2     MOVWF sign
0ECC  082D     MOVF aexp, W
0ECD  00FD     MOVWF 0x7D
0ECE  087D     MOVF 0x7D, W
0ECF  00F3     MOVWF a
0ED0  318D     MOVLP 0xD
0ED1  255F     CALL 0x55F
0ED2  318E     MOVLP 0xE
576:                   ++cp;
0ED3  3001     MOVLW 0x1
0ED4  0140     MOVLB 0x0
0ED5  07AB     ADDWF cp, F
0ED6  3000     MOVLW 0x0
0ED7  3DAC     ADDWFC 0x2C, F
577:                   ++i;
0ED8  3001     MOVLW 0x1
0ED9  07A7     ADDWF i, F
0EDA  3000     MOVLW 0x0
0EDB  3DA8     ADDWFC dividend, F
578:               }
579:           
580:               /* Left justify, pad on right ? */
581:               if (flags & MINUS_FLAG) {
0EEA  0141     MOVLB 0x1
0EEB  1C52     BTFSS flags, 0x0
0EEC  2EEE     GOTO 0x6EE
0EED  2EEF     GOTO 0x6EF
0EEE  2F10     GOTO 0x710
0EEF  2F01     GOTO 0x701
582:                   while (l < w) {
0F01  0140     MOVLB 0x0
0F02  0831     MOVF 0x31, W
0F03  3A80     XORLW 0x80
0F04  00FB     MOVWF 0x7B
0F05  082A     MOVF 0x2A, W
0F06  3A80     XORLW 0x80
0F07  027B     SUBWF 0x7B, W
0F08  1D03     BTFSS STATUS, 0x2
0F09  2F0C     GOTO 0x70C
0F0A  0829     MOVF grs, W
0F0B  0230     SUBWF d, W
0F0C  1C03     BTFSS STATUS, 0x0
0F0D  2F0F     GOTO 0x70F
0F0E  2F10     GOTO 0x710
0F0F  2EF0     GOTO 0x6F0
583:                       fputc(' ', fp);
0EF0  3020     MOVLW 0x20
0EF1  00F1     MOVWF counter
0EF2  3000     MOVLW 0x0
0EF3  00F2     MOVWF sign
0EF4  0140     MOVLB 0x0
0EF5  082D     MOVF aexp, W
0EF6  00FB     MOVWF 0x7B
0EF7  087B     MOVF 0x7B, W
0EF8  00F3     MOVWF a
0EF9  318D     MOVLP 0xD
0EFA  255F     CALL 0x55F
0EFB  318E     MOVLP 0xE
584:                       ++l;
0EFC  3001     MOVLW 0x1
0EFD  0140     MOVLB 0x0
0EFE  07B0     ADDWF d, F
0EFF  3000     MOVLW 0x0
0F00  3DB1     ADDWFC 0x31, F
585:                   }
586:               }
587:           
588:               return l;
0F10  0140     MOVLB 0x0
0F11  0831     MOVF 0x31, W
0F12  00FA     MOVWF 0x7A
0F13  0830     MOVF d, W
0F14  00F9     MOVWF fp
589:           }
0F15  0008     RETURN
590:           #endif
591:           
592:           #ifdef _VFPF_U
593:           static _INLINE int utoa(FILE *fp, unsigned long long d)
594:           {
595:               int i, p, w;
596:               unsigned long long n;
597:           
598:               /* Adjust flags, precision, width */
599:               if (!(prec < 0)) {
600:                   flags &= ~ZERO_FLAG;
601:               }
602:               p = (0 < prec) ? prec : 1;
603:               w = width;
604:           
605:               /* Convert to decimal, possibly filling on the left with zeroes */
606:               n = d;
607:               i = sizeof(dbuf) - 1;
608:               dbuf[i] = '\0';
609:               while (i && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
610:                   --i;
611:                   dbuf[i] = '0' + (n % 10);
612:                   --p;
613:                   --w;
614:                   n = n / 10;
615:               }
616:           
617:               /* Put out padded string */
618:               return pad(fp, &dbuf[i], w);
619:           }
620:           #endif
621:           
622:           #if defined(_VFPF_X) || defined(_VFPF_P)
623:           static _INLINE int xtoa(FILE *fp, unsigned long long d, char x)
624:           {
625:               int c, i, p, w;
626:               unsigned long long n;
627:           
628:               /* Adjust, flags, precision, width */
629:               if (!(prec < 0)) {
630:                   flags &= ~ZERO_FLAG;
631:               }
632:               p = (0 < prec) ? prec : 1;
633:               w = width;
634:               if (flags & POUND_FLAG) {
635:                   w -= 2;
636:               }
637:           
638:               /* Convert to hexadecimal, possibly filling on the left with zeroes */
639:               n = d;
640:               i = sizeof(dbuf) - 1;
641:               dbuf[i] = '\0';
642:               while (!(i < 2) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
643:                   --i;
644:                   c = n & 0x0f;
645:                   c = (c < 10) ? '0' + c : 'a' + (c - 10);
646:                   if (isupper((int)x) && isalpha(c)) {
647:                       c = toupper(c);
648:                   }
649:                   dbuf[i] = (char)c;
650:                   --p;
651:                   --w;
652:                   n = n >> 4;
653:               }
654:           
655:               /* Display prefix if required */
656:               if (flags & POUND_FLAG) {
657:                   --i;
658:                   dbuf[i] = x;
659:                   --i;
660:                   dbuf[i] = '0';
661:               }
662:           
663:               /* Put out padded string */
664:               return pad(fp, &dbuf[i], w);
665:           }
666:           #endif
667:           
668:           /* Consume and convert the next part of the format string */
669:           #ifdef _VFPF_CONVERT
670:           static _INLINE int vfpfcnvrt(FILE *fp, char *fmt[], va_list ap)
013A  0140     MOVLB 0x0
671:           {
672:               char c, *cp, ct[3];
673:               int done, i;
674:               long long ll;
675:               unsigned long long llu;
676:               long double f;
677:               void *vp;
678:           
679:               /* Conversion ? */
680:               if ((*fmt)[0] == '%') {
013C  084E     MOVF fmt, W
013D  0086     MOVWF FSR1
013E  0187     CLRF FSR1H
013F  3F40     MOVIW [0]FSR1
0140  00D0     MOVWF 0x50
0141  3F41     MOVIW [1]FSR1
0142  00D1     MOVWF 0x51
0143  0850     MOVF 0x50, W
0144  0084     MOVWF FSR0
0145  0851     MOVF 0x51, W
0146  0085     MOVWF FSR0H
0147  0012     MOVIW FSR0++
0148  3A25     XORLW 0x25
0149  1D03     BTFSS STATUS, 0x2
014A  294C     GOTO 0x14C
014B  294D     GOTO 0x14D
014C  2A24     GOTO 0x224
681:                   ++*fmt;
014D  084E     MOVF fmt, W
014E  0086     MOVWF FSR1
014F  0187     CLRF FSR1H
0150  3001     MOVLW 0x1
0151  0781     ADDWF INDF1, F
0152  3141     ADDFSR 1, 1
0153  1803     BTFSC STATUS, 0x0
0154  0A81     INCF INDF1, F
682:           
683:                   flags = width = 0;
0155  0141     MOVLB 0x1
0156  01CE     CLRF width
0157  01CF     CLRF 0xCF
0158  01D2     CLRF flags
0159  01D3     CLRF 0xD3
684:                   prec = -1;
015A  30FF     MOVLW 0xFF
015B  00D0     MOVWF prec
015C  30FF     MOVLW 0xFF
015D  00D1     MOVWF 0xD1
685:           
686:           #ifdef _VFPF_FLAGS
687:                   /* Get flags */
688:                   done = 0;
689:                   while (!done) {
690:                       switch ((*fmt)[0]) {
691:                           case '-' :
692:                               flags |= MINUS_FLAG;
693:                               ++*fmt;
694:                               break;
695:                           case '0' :
696:                               flags |= ZERO_FLAG;
697:                               ++*fmt;
698:                               break;
699:                           case '+' :
700:                               flags |= PLUS_FLAG;
701:                               ++*fmt;
702:                               break;
703:                           case ' ' :
704:                               flags |= SPACE_FLAG;
705:                               ++*fmt;
706:                               break;
707:                           case '#' :
708:                               flags |= POUND_FLAG;
709:                               ++*fmt;
710:                               break;
711:                           default:
712:                               done = 1;
713:                               break;
714:                       }
715:                   }
716:                   if (flags & MINUS_FLAG) {
717:                       flags &= ~ZERO_FLAG;
718:                   }
719:           #endif
720:           
721:           #ifdef _VFPF_WIDTH
722:                   /* Get field width */
723:                   if ((*fmt)[0] == '*') {
724:                       ++*fmt;
725:                       width = va_arg(ap, int);
726:                       if (width < 0) {
727:                           flags |= MINUS_FLAG;
728:                           width = -width;
729:                       }
730:                   } else {
731:                       width = atoi(*fmt);
732:                       while (isdigit((*fmt)[0])) {
733:                           ++*fmt;
734:                       }
735:                   }
736:           #endif
737:           
738:           #ifdef _VFPF_PRECISION
739:                   /* Get precision */
740:                   if ((*fmt)[0] == '.') {
741:                       prec = 0;
742:                       ++*fmt;
743:                       if ((*fmt)[0] == '*') {
744:                           ++*fmt;
745:                           prec = va_arg(ap, int);
746:                       } else {
747:                           prec = atoi(*fmt);
748:                           while (isdigit((*fmt)[0])) {
749:                               ++*fmt;
750:                           }
751:                       }
752:                   }
753:           #endif
754:           
755:           #if defined(_VFPF_A) || defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
756:                   /* Case-folded conversion types */
757:                   ct[0] = tolower((int)(*fmt)[0]);
758:                   if (ct[0]) {
759:                       ct[1] = tolower((int)(*fmt)[1]);
760:                       if (ct[1]) {
761:                           ct[2] = tolower((int)(*fmt)[2]);
762:                       }
763:                   }
764:           #endif
765:           
766:           #ifdef _VFPF_A
767:                   /* 'a' style (hex) floating point */
768:                   if (ct[0] == 'a') {
769:           
770:                       c = (*fmt)[0];
771:                       ++*fmt;
772:                       f = (long double)va_arg(ap, double);
773:                                   
774:                       return atoa(fp, f, c);
775:                   }
776:                   if (!strncmp(ct, "la", CSTRLEN("la"))) {
777:           
778:                       c = (*fmt)[1];
779:                       if (isupper((int)(*fmt)[0])) {
780:                           f = va_arg(ap, long double);
781:                       } else {
782:                           f = (long double)va_arg(ap, double);
783:                       }
784:                       *fmt += CSTRLEN("la");
785:                                   
786:                       return atoa(fp, f, c);
787:                   }
788:           #endif
789:           
790:           #ifdef _VFPF_C
791:                   /* Character */
792:                   if (*fmt[0] == 'c') {
793:                       ++*fmt;
794:                       c = (unsigned char)va_arg(ap, int);
795:                       return ctoa(fp, c);
796:                   }
797:           #endif
798:           
799:           #ifdef _VFPF_D
800:           #ifdef _VFPF_HH
801:                   /* Character decimal integer */
802:                   if (!strncmp(*fmt, "hhd", CSTRLEN("hhd")) || \
803:                       !strncmp(*fmt, "hhi", CSTRLEN("hhi"))) {
804:           
805:                       *fmt += CSTRLEN("hhd");
806:                       ll = (long long)(signed char)va_arg(ap, int);
807:                                   
808:                       return dtoa(fp, ll);
809:                   }
810:           #endif
811:           
812:           #ifdef _VFPF_H
813:                   /* Short decimal integer */
814:                   if (!strncmp(*fmt, "hd", CSTRLEN("hd")) || \
815:                       !strncmp(*fmt, "hi", CSTRLEN("hi"))) {
816:           
817:                       *fmt += CSTRLEN("hd");
818:                       ll = (long long)(short)va_arg(ap, int);
819:                                   
820:                       return dtoa(fp, ll);
821:                   }
822:           #endif
823:           
824:                   /* Decimal integer */
825:                   if ((*fmt[0] == 'd') || (*fmt[0] == 'i')) {
015E  0140     MOVLB 0x0
015F  084E     MOVF fmt, W
0160  0086     MOVWF FSR1
0161  0187     CLRF FSR1H
0162  3F40     MOVIW [0]FSR1
0163  00D0     MOVWF 0x50
0164  3F41     MOVIW [1]FSR1
0165  00D1     MOVWF 0x51
0166  0850     MOVF 0x50, W
0167  0084     MOVWF FSR0
0168  0851     MOVF 0x51, W
0169  0085     MOVWF FSR0H
016A  0012     MOVIW FSR0++
016B  3A64     XORLW 0x64
016C  1903     BTFSC STATUS, 0x2
016D  296F     GOTO 0x16F
016E  2970     GOTO 0x170
016F  2981     GOTO 0x181
0170  084E     MOVF fmt, W
0171  0086     MOVWF FSR1
0172  0187     CLRF FSR1H
0173  3F40     MOVIW [0]FSR1
0174  00D0     MOVWF 0x50
0175  3F41     MOVIW [1]FSR1
0176  00D1     MOVWF 0x51
0177  0850     MOVF 0x50, W
0178  0084     MOVWF FSR0
0179  0851     MOVF 0x51, W
017A  0085     MOVWF FSR0H
017B  0012     MOVIW FSR0++
017C  3A69     XORLW 0x69
017D  1D03     BTFSS STATUS, 0x2
017E  2980     GOTO 0x180
017F  2981     GOTO 0x181
0180  29BC     GOTO 0x1BC
826:           
827:                       ++*fmt;
0181  084E     MOVF fmt, W
0182  0086     MOVWF FSR1
0183  0187     CLRF FSR1H
0184  3001     MOVLW 0x1
0185  0781     ADDWF INDF1, F
0186  3141     ADDFSR 1, 1
0187  1803     BTFSC STATUS, 0x0
0188  0A81     INCF INDF1, F
828:                       ll = (long long)va_arg(ap, int);
0189  084F     MOVF ap, W
018A  0086     MOVWF FSR1
018B  0187     CLRF FSR1H
018C  0801     MOVF INDF1, W
018D  0084     MOVWF FSR0
018E  0185     CLRF FSR0H
018F  3002     MOVLW 0x2
0190  0781     ADDWF INDF1, F
0191  3F00     MOVIW [0]FSR0
0192  00D0     MOVWF 0x50
0193  3F01     MOVIW [1]FSR0
0194  00D1     MOVWF 0x51
0195  0850     MOVF 0x50, W
0196  00D5     MOVWF ll
0197  0851     MOVF 0x51, W
0198  00D6     MOVWF 0x56
0199  0D89     RLF WREG, F
019A  3B89     SUBWFB WREG, F
019B  0989     COMF WREG, F
019C  00D7     MOVWF 0x57
019D  00D8     MOVWF 0x58
019E  00D9     MOVWF 0x59
019F  00DA     MOVWF 0x5A
01A0  00DB     MOVWF 0x5B
01A1  00DC     MOVWF 0x5C
829:                                   
830:                       return dtoa(fp, ll);
01A2  0855     MOVF ll, W
01A3  00B0     MOVWF d
01A4  0856     MOVF 0x56, W
01A5  00B1     MOVWF 0x31
01A6  0857     MOVF 0x57, W
01A7  00B2     MOVWF 0x32
01A8  0858     MOVF 0x58, W
01A9  00B3     MOVWF temp
01AA  0859     MOVF 0x59, W
01AB  00B4     MOVWF 0x34
01AC  085A     MOVF 0x5A, W
01AD  00B5     MOVWF 0x35
01AE  085B     MOVF 0x5B, W
01AF  00B6     MOVWF 0x36
01B0  085C     MOVF 0x5C, W
01B1  00B7     MOVWF 0x37
01B2  085F     MOVF fp, W
01B3  3182     MOVLP 0x2
01B4  2248     CALL 0x248
01B5  3181     MOVLP 0x1
01B6  0140     MOVLB 0x0
01B7  0831     MOVF 0x31, W
01B8  00CF     MOVWF ap
01B9  0830     MOVF d, W
01BA  00CE     MOVWF fmt
01BB  2A47     GOTO 0x247
831:                   }
832:           
833:           #ifdef _VFPF_L
834:                   /* Long decimal integer */
835:                   if (!strncmp(*fmt, "ld", CSTRLEN("ld")) || \
836:                       !strncmp(*fmt, "li", CSTRLEN("li"))) {
837:           
838:                       *fmt += CSTRLEN("ld");
839:                       ll = (long long)va_arg(ap, long);
840:                                   
841:                       return dtoa(fp, ll);
842:                   }
843:           #endif
844:           
845:           #ifdef _VFPF_LL
846:                   /* Long long decimal integer */
847:                   if (!strncmp(*fmt, "lld", CSTRLEN("lld")) || \
848:                       !strncmp(*fmt, "lli", CSTRLEN("lli"))) {
849:           
850:                       *fmt += CSTRLEN("lld");
851:                       ll = va_arg(ap, long long);
852:                                   
853:                       return dtoa(fp, ll);
854:                   }
855:           #endif
856:           
857:           #ifdef _VFPF_J
858:                   /* intmax_t decimal integer */
859:                   if (!strncmp(*fmt, "jd", CSTRLEN("jd")) || \
860:                       !strncmp(*fmt, "ji", CSTRLEN("ji"))) {
861:           
862:                       *fmt += CSTRLEN("jd");
863:                       ll = (long long)va_arg(ap, intmax_t);
864:                                   
865:                       return dtoa(fp, ll);
866:                   }
867:           #endif
868:           
869:           #ifdef _VFPF_T
870:                   /* ptrdiff_t decimal integer */
871:                   if (!strncmp(*fmt, "td", CSTRLEN("td")) || \
872:                       !strncmp(*fmt, "ti", CSTRLEN("ti"))) {
873:           
874:                       *fmt += CSTRLEN("td");
875:                       ll = (long long)va_arg(ap, ptrdiff_t);
876:                                   
877:                       return dtoa(fp, ll);
878:                   }
879:           #endif
880:           
881:           #ifdef _VFPF_Z
882:                   /* size_t decimal integer */
883:                   if (!strncmp(*fmt, "zd", CSTRLEN("zd")) || \
884:                       !strncmp(*fmt, "zi", CSTRLEN("zi"))) {
885:           
886:                       *fmt += CSTRLEN("zd");
887:                       ll = (long long)va_arg(ap, size_t);
888:                                   
889:                       return dtoa(fp, ll);
890:                   }
891:           #endif
892:           #endif
893:           
894:           #ifdef _VFPF_E
895:                   /* 'e' style floating point */
896:                   if (ct[0] == 'e') {
897:           
898:                       c = (*fmt)[0];
899:                       ++*fmt;
900:                       f = (long double)va_arg(ap, double);
901:                                   
902:                       return efgtoa(fp, f, c);
903:                   }
904:                   if (!strncmp(ct, "le", CSTRLEN("le"))) {
905:           
906:                       c = (*fmt)[1];
907:                       if (isupper((int)(*fmt)[0])) {
908:                           f = va_arg(ap, long double);
909:                       } else {
910:                           f = (long double)va_arg(ap, double);
911:                       }
912:                       *fmt += CSTRLEN("lf");
913:                                   
914:                       return efgtoa(fp, f, c);
915:                   }
916:           #endif
917:           
918:           #ifdef _VFPF_F
919:                   /* 'f' style floating point */
920:                   if (ct[0] == 'f') {
921:           
922:                       c = (*fmt)[0];
923:                       ++*fmt;
924:                       f = (long double)va_arg(ap, double);
925:                                   
926:                       return efgtoa(fp, f, c);
927:                   }
928:                   if (!strncmp(ct, "lf", CSTRLEN("lf"))) {
929:           
930:                       c = (*fmt)[1];
931:                       if (isupper((int)(*fmt)[0])) {
932:                           f = va_arg(ap, long double);
933:                       } else {
934:                           f = (long double)va_arg(ap, double);
935:                       }
936:                       *fmt += CSTRLEN("lf");
937:                                   
938:                       return efgtoa(fp, f, c);
939:                   }
940:           #endif
941:           
942:           #ifdef _VFPF_G
943:                   /* 'g' style floating point */
944:                   if (ct[0] == 'g') {
945:           
946:                       c = (*fmt)[0];
947:                       ++*fmt;
948:                       f = (long double)va_arg(ap, double);
949:                                   
950:                       return efgtoa(fp, f, c);
951:                   }
952:                   if (!strncmp(ct, "lg", CSTRLEN("lg"))) {
953:           
954:                       c = (*fmt)[1];
955:                       if (isupper((int)(*fmt)[0])) {
956:                           f = va_arg(ap, long double);
957:                       } else {
958:                           f = (long double)va_arg(ap, double);
959:                       }
960:                       *fmt += CSTRLEN("lg");
961:                                   
962:                       return efgtoa(fp, f, c);
963:                   }
964:           #endif
965:           
966:           #ifdef _VFPF_O
967:           #ifdef _VFPF_HH
968:                   /* Character octal integer */
969:                   if (!strncmp(*fmt, "hho", CSTRLEN("hho"))) {
970:           
971:                       *fmt += CSTRLEN("hho");
972:                       llu = (unsigned long long)(unsigned char)va_arg(ap, int);
973:                                   
974:                       return otoa(fp, llu);
975:                   }
976:           #endif
977:           
978:           #ifdef _VFPF_H
979:                   /* Short octal integer */
980:                   if (!strncmp(*fmt, "ho", CSTRLEN("ho"))) {
981:           
982:                       *fmt += CSTRLEN("ho");
983:                       llu = (unsigned long long)(unsigned short)va_arg(ap, int);
984:                                   
985:                       return otoa(fp, llu);
986:                   }
987:           #endif
988:           
989:                   /* Octal integer */
990:                   if (*fmt[0] == 'o') {
991:           
992:                       ++*fmt;
993:                       llu = (unsigned long long)va_arg(ap, unsigned int);
994:                                   
995:                       return otoa(fp, llu);
996:                   }
997:           
998:           #ifdef _VFPF_L
999:                   /* Long octal integer */
1000:                  if (!strncmp(*fmt, "lo", CSTRLEN("lo"))) {
1001:          
1002:                      *fmt += CSTRLEN("lo");
1003:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1004:                                  
1005:                      return otoa(fp, llu);
1006:                  }
1007:          #endif
1008:          
1009:          #ifdef _VFPF_LL
1010:                  /* Long long octal integer */
1011:                  if (!strncmp(*fmt, "llo", CSTRLEN("llo"))) {
1012:          
1013:                      *fmt += CSTRLEN("llo");
1014:                      llu = va_arg(ap, unsigned long long);
1015:                                  
1016:                      return otoa(fp, llu);
1017:                  }
1018:          #endif
1019:          
1020:          #ifdef _VFPF_J
1021:                  /* uintmax_t octal integer */
1022:                  if (!strncmp(*fmt, "jo", CSTRLEN("jo"))) {
1023:          
1024:                      *fmt += CSTRLEN("jo");
1025:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1026:                                  
1027:                      return otoa(fp, llu);
1028:                  }
1029:          #endif
1030:          
1031:          #ifdef _VFPF_T
1032:                  /* ptrdiff_t octal integer */
1033:                  if (!strncmp(*fmt, "to", CSTRLEN("to"))) {
1034:          
1035:                      *fmt += CSTRLEN("to");
1036:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1037:                                  
1038:                      return otoa(fp, llu);
1039:                  }
1040:          #endif
1041:          
1042:          #ifdef _VFPF_Z
1043:                  /* size_t octal integer */
1044:                  if (!strncmp(*fmt, "zo", CSTRLEN("zo"))) {
1045:          
1046:                      *fmt += CSTRLEN("zo");
1047:                      llu = (unsigned long long)va_arg(ap, size_t);
1048:                                  
1049:                      return otoa(fp, llu);
1050:                  }
1051:          #endif
1052:          #endif
1053:          
1054:                  /* Character count */
1055:          #ifdef _VFPF_N
1056:          
1057:          #ifdef _VFPF_HH
1058:                  if (!strncmp(*fmt, "hhn", CSTRLEN("hhn"))) {
1059:          
1060:                      *fmt += CSTRLEN("hhn");
1061:                      vp = (void *)va_arg(ap, char *);
1062:                      *(char *)vp = (char)nout;
1063:                      return 0;
1064:                  }
1065:          #endif
1066:          
1067:          #ifdef _VFPF_H
1068:                  if (!strncmp(*fmt, "hn", CSTRLEN("hn"))) {
1069:          
1070:                      *fmt += CSTRLEN("hn");
1071:                      vp = (void *)va_arg(ap, short *);
1072:                      *(short *)vp = (short)nout;
1073:                      return 0;
1074:                  }
1075:          #endif
1076:          
1077:                  if (*fmt[0] == 'n') {
1078:                      ++*fmt;
1079:                      vp = (void *)va_arg(ap, int *);
1080:                      *(int *)vp = nout;
1081:                      return 0;
1082:                  }
1083:          
1084:          #ifdef _VFPF_L
1085:                  if (!strncmp(*fmt, "ln", CSTRLEN("ln"))) {
1086:          
1087:                      *fmt += CSTRLEN("ln");
1088:                      vp = (void *)va_arg(ap, long *);
1089:                      *(long *)vp = (long)nout;
1090:                      return 0;
1091:                  }
1092:          #endif
1093:          
1094:          #ifdef _VFPF_LL
1095:                  if (!strncmp(*fmt, "lln", CSTRLEN("lln"))) {
1096:          
1097:                      *fmt += CSTRLEN("lln");
1098:                      vp = (void *)va_arg(ap, long long *);
1099:                      *(long long *)vp = (long long)nout;
1100:                      return 0;
1101:                  }
1102:          #endif
1103:          
1104:          #ifdef _VFPF_J
1105:                  if (!strncmp(*fmt, "jn", CSTRLEN("jn"))) {
1106:          
1107:                      *fmt += CSTRLEN("jn");
1108:                      vp = (void *)va_arg(ap, uintmax_t *);
1109:                      *(uintmax_t *)vp = (uintmax_t)nout;
1110:                      return 0;
1111:                  }
1112:          #endif
1113:          
1114:          #ifdef _VFPF_T
1115:                  if (!strncmp(*fmt, "tn", CSTRLEN("tn"))) {
1116:          
1117:                      *fmt += CSTRLEN("tn");
1118:                      vp = (void *)va_arg(ap, ptrdiff_t *);
1119:                      *(ptrdiff_t *)vp = (ptrdiff_t)nout;
1120:                      return 0;
1121:                  }
1122:          #endif
1123:          
1124:          #ifdef _VFPF_Z
1125:                  if (!strncmp(*fmt, "zn", CSTRLEN("zn"))) {
1126:          
1127:                      *fmt += CSTRLEN("zn");
1128:                      vp = (void *)va_arg(ap, size_t *);
1129:                      *(size_t *)vp = (size_t)nout;
1130:                      return 0;
1131:                  }
1132:          #endif
1133:          
1134:          #endif
1135:          
1136:          #ifdef _VFPF_P
1137:                  /* Pointer */
1138:                  if (*fmt[0] == 'p') {
1139:          
1140:                      ++*fmt;
1141:                      llu = (unsigned long long)(size_t)va_arg(ap, void *);
1142:                                  
1143:                      return xtoa(fp, llu, 'x');
1144:                  }
1145:          #endif
1146:          
1147:          #ifdef _VFPF_S
1148:                  /* String */
1149:                  if (*fmt[0] == 's') {
01BC  084E     MOVF fmt, W
01BD  0086     MOVWF FSR1
01BE  0187     CLRF FSR1H
01BF  3F40     MOVIW [0]FSR1
01C0  00D0     MOVWF 0x50
01C1  3F41     MOVIW [1]FSR1
01C2  00D1     MOVWF 0x51
01C3  0850     MOVF 0x50, W
01C4  0084     MOVWF FSR0
01C5  0851     MOVF 0x51, W
01C6  0085     MOVWF FSR0H
01C7  0012     MOVIW FSR0++
01C8  3A73     XORLW 0x73
01C9  1D03     BTFSS STATUS, 0x2
01CA  29CC     GOTO 0x1CC
01CB  29CD     GOTO 0x1CD
01CC  29EF     GOTO 0x1EF
1150:          
1151:                      ++*fmt;
01CD  084E     MOVF fmt, W
01CE  0086     MOVWF FSR1
01CF  0187     CLRF FSR1H
01D0  3001     MOVLW 0x1
01D1  0781     ADDWF INDF1, F
01D2  3141     ADDFSR 1, 1
01D3  1803     BTFSC STATUS, 0x0
01D4  0A81     INCF INDF1, F
1152:                      cp = va_arg(ap, char *);
01D5  084F     MOVF ap, W
01D6  0086     MOVWF FSR1
01D7  0187     CLRF FSR1H
01D8  0801     MOVF INDF1, W
01D9  0084     MOVWF FSR0
01DA  0185     CLRF FSR0H
01DB  3002     MOVLW 0x2
01DC  0781     ADDWF INDF1, F
01DD  3F00     MOVIW [0]FSR0
01DE  00DD     MOVWF cp
01DF  3F01     MOVIW [1]FSR0
01E0  00DE     MOVWF 0x5E
1153:          
1154:                      return stoa(fp, cp);
01E1  085E     MOVF 0x5E, W
01E2  00FA     MOVWF 0x7A
01E3  085D     MOVF cp, W
01E4  00F9     MOVWF fp
01E5  085F     MOVF fp, W
01E6  318E     MOVLP 0xE
01E7  263F     CALL 0x63F
01E8  3181     MOVLP 0x1
01E9  087A     MOVF 0x7A, W
01EA  0140     MOVLB 0x0
01EB  00CF     MOVWF ap
01EC  0879     MOVF fp, W
01ED  00CE     MOVWF fmt
01EE  2A47     GOTO 0x247
1155:                  }
1156:          #endif
1157:          
1158:          #ifdef _VFPF_U
1159:          #ifdef _VFPF_HH
1160:                  /* Unsigned character decimal integer */
1161:                  if (!strncmp(*fmt, "hhu", CSTRLEN("hhu"))) {
1162:          
1163:                      *fmt += CSTRLEN("hhu");
1164:                      llu = (unsigned long long)(unsigned char)va_arg(ap, int);
1165:                                  
1166:                      return utoa(fp, llu);
1167:                  }
1168:          #endif
1169:          
1170:          #ifdef _VFPF_H
1171:                  /* Unsigned short decimal integer */
1172:                  if (!strncmp(*fmt, "hu", CSTRLEN("hu"))) {
1173:          
1174:                      *fmt += CSTRLEN("hu");
1175:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1176:                                  
1177:                      return utoa(fp, llu);
1178:                  }
1179:          #endif
1180:          
1181:                  /* Unsigned decimal integer */
1182:                  if (*fmt[0] == 'u') {
1183:          
1184:                      ++*fmt;
1185:                      llu = (unsigned long long)va_arg(ap, unsigned int);
1186:                                  
1187:                      return utoa(fp, llu);
1188:                  }
1189:          
1190:          #ifdef _VFPF_L
1191:                  /* Unsigned long decimal integer */
1192:                  if (!strncmp(*fmt, "lu", CSTRLEN("lu"))) {
1193:          
1194:                      *fmt += CSTRLEN("lu");
1195:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1196:                                  
1197:                      return utoa(fp, llu);
1198:                  }
1199:          #endif
1200:          
1201:          #ifdef _VFPF_LL
1202:                  /* Unsigned long long decimal integer */
1203:                  if (!strncmp(*fmt, "llu", CSTRLEN("llu"))) {
1204:          
1205:                      *fmt += CSTRLEN("llu");
1206:                      llu = va_arg(ap, unsigned long long);
1207:                                  
1208:                      return utoa(fp, llu);
1209:                  }
1210:          #endif
1211:          
1212:          #ifdef _VFPF_J
1213:                  /* uintmax_t decimal integer */
1214:                  if (!strncmp(*fmt, "ju", CSTRLEN("ju"))) {
1215:          
1216:                      *fmt += CSTRLEN("ju");
1217:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1218:                                  
1219:                      return utoa(fp, llu);
1220:                  }
1221:          #endif
1222:          
1223:          #ifdef _VFPF_T
1224:                  /* ptrdiff_t decimal integer */
1225:                  if (!strncmp(*fmt, "tu", CSTRLEN("tu"))) {
1226:          
1227:                      *fmt += CSTRLEN("tu");
1228:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1229:                                  
1230:                      return utoa(fp, llu);
1231:                  }
1232:          #endif
1233:          
1234:          #ifdef _VFPF_Z
1235:                  /* size_t decimal integer */
1236:                  if (!strncmp(*fmt, "zu", CSTRLEN("zu"))) {
1237:          
1238:                      *fmt += CSTRLEN("zu");
1239:                      llu = (unsigned long long)va_arg(ap, size_t);
1240:                                  
1241:                      return utoa(fp, llu);
1242:                  }
1243:          #endif
1244:          #endif
1245:          
1246:          #ifdef _VFPF_X
1247:          #ifdef _VFPF_HH
1248:                  /* Character hexadecimal integer */
1249:                  if (!strncmp(*fmt, "hhx", CSTRLEN("hhx")) || \
1250:                      !strncmp(*fmt, "hhX", CSTRLEN("hhX"))) {
1251:          
1252:                      c = (*fmt)[2];
1253:                      *fmt += CSTRLEN("hhx");
1254:                      llu = (unsigned long long)(unsigned char)va_arg(ap, int);
1255:                                  
1256:                      return xtoa(fp, llu, c);
1257:                  }
1258:          #endif
1259:          
1260:          #ifdef _VFPF_H
1261:                  /* Short hexadecimal integer */
1262:                  if (!strncmp(*fmt, "hx", CSTRLEN("hx")) || \
1263:                      !strncmp(*fmt, "hX", CSTRLEN("hX"))) {
1264:          
1265:                      c = (*fmt)[1];
1266:                      *fmt += CSTRLEN("hx");
1267:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1268:                                  
1269:                      return xtoa(fp, llu, c);
1270:                  }
1271:          #endif
1272:          
1273:                  /* Hexadecimal integer */
1274:                  if ((*fmt[0] == 'x') || (*fmt[0] == 'X')) {
1275:          
1276:                      c = (*fmt)[0];
1277:                      ++*fmt;
1278:                      llu = (unsigned long long)va_arg(ap, unsigned int);
1279:                                  
1280:                      return xtoa(fp, llu, c);
1281:                  }
1282:          
1283:          #ifdef _VFPF_L
1284:                  /* Long hexadecimal integer */
1285:                  if (!strncmp(*fmt, "lx", CSTRLEN("lx")) || \
1286:                      !strncmp(*fmt, "lX", CSTRLEN("lX"))) {
1287:          
1288:                      c = (*fmt)[1];
1289:                      *fmt += CSTRLEN("lx");
1290:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1291:                                  
1292:                      return xtoa(fp, llu, c);
1293:                  }
1294:          #endif
1295:          
1296:          #ifdef _VFPF_LL
1297:                  /* Long long hexadecimal integer */
1298:                  if (!strncmp(*fmt, "llx", CSTRLEN("llx")) || \
1299:                      !strncmp(*fmt, "llX", CSTRLEN("llX"))) {
1300:          
1301:                      c = (*fmt)[2];
1302:                      *fmt += CSTRLEN("llx");
1303:                      llu = va_arg(ap, unsigned long long);
1304:                                  
1305:                      return xtoa(fp, llu, c);
1306:                  }
1307:          #endif
1308:          
1309:          #ifdef _VFPF_J
1310:                  /* uintmax_t hexadecimal integer */
1311:                  if (!strncmp(*fmt, "jx", CSTRLEN("jx")) || \
1312:                      !strncmp(*fmt, "jX", CSTRLEN("jX"))) {
1313:          
1314:                      c = (*fmt)[1];
1315:                      *fmt += CSTRLEN("jx");
1316:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1317:                                  
1318:                      return xtoa(fp, llu, c);
1319:                  }
1320:          #endif
1321:          
1322:          #ifdef _VFPF_T
1323:                  /* ptrdiff_t hexadecimal integer */
1324:                  if (!strncmp(*fmt, "tx", CSTRLEN("tx")) || \
1325:                      !strncmp(*fmt, "tX", CSTRLEN("tX"))) {
1326:          
1327:                      c = (*fmt)[1];
1328:                      *fmt += CSTRLEN("tx");
1329:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1330:                                  
1331:                      return xtoa(fp, llu, c);
1332:                  }
1333:          #endif
1334:          
1335:          #ifdef _VFPF_Z
1336:                  /* size_t hexadecimal integer */
1337:                  if (!strncmp(*fmt, "zx", CSTRLEN("zx")) || \
1338:                      !strncmp(*fmt, "zX", CSTRLEN("zX"))) {
1339:          
1340:                      c = (*fmt)[1];
1341:                      *fmt += CSTRLEN("zx");
1342:                      llu = (unsigned long long)va_arg(ap, size_t);
1343:                                  
1344:                      return xtoa(fp, llu, c);
1345:                  }
1346:          #endif
1347:          #endif
1348:          
1349:                  /* 'Escaped' '%' character */
1350:                  if ((*fmt)[0] == '%') {
01EF  084E     MOVF fmt, W
01F0  0086     MOVWF FSR1
01F1  0187     CLRF FSR1H
01F2  3F40     MOVIW [0]FSR1
01F3  00D0     MOVWF 0x50
01F4  3F41     MOVIW [1]FSR1
01F5  00D1     MOVWF 0x51
01F6  0850     MOVF 0x50, W
01F7  0084     MOVWF FSR0
01F8  0851     MOVF 0x51, W
01F9  0085     MOVWF FSR0H
01FA  0012     MOVIW FSR0++
01FB  3A25     XORLW 0x25
01FC  1D03     BTFSS STATUS, 0x2
01FD  29FF     GOTO 0x1FF
01FE  2A00     GOTO 0x200
01FF  2A19     GOTO 0x219
1351:                      ++*fmt;
0200  084E     MOVF fmt, W
0201  0086     MOVWF FSR1
0202  0187     CLRF FSR1H
0203  3001     MOVLW 0x1
0204  0781     ADDWF INDF1, F
0205  3141     ADDFSR 1, 1
0206  1803     BTFSC STATUS, 0x0
0207  0A81     INCF INDF1, F
1352:                      fputc((int)'%', fp);
0208  3025     MOVLW 0x25
0209  00F1     MOVWF counter
020A  3000     MOVLW 0x0
020B  00F2     MOVWF sign
020C  085F     MOVF fp, W
020D  00D0     MOVWF 0x50
020E  0850     MOVF 0x50, W
020F  00F3     MOVWF a
0210  318D     MOVLP 0xD
0211  255F     CALL 0x55F
0212  3181     MOVLP 0x1
1353:                      return 1;
0213  3001     MOVLW 0x1
0214  0140     MOVLB 0x0
0215  00CE     MOVWF fmt
0216  3000     MOVLW 0x0
0217  00CF     MOVWF ap
0218  2A47     GOTO 0x247
1354:                  }
1355:          
1356:                  /* Unrecognized conversion */
1357:                  ++*fmt;
0219  084E     MOVF fmt, W
021A  0086     MOVWF FSR1
021B  0187     CLRF FSR1H
021C  3001     MOVLW 0x1
021D  0781     ADDWF INDF1, F
021E  3141     ADDFSR 1, 1
021F  1803     BTFSC STATUS, 0x0
0220  0A81     INCF INDF1, F
1358:                  return 0;
0221  01CE     CLRF fmt
0222  01CF     CLRF ap
0223  2A47     GOTO 0x247
1359:              }
1360:          
1361:              /* No conversion, just intervening text */
1362:              fputc((int)(*fmt)[0], fp);
0224  084E     MOVF fmt, W
0225  0086     MOVWF FSR1
0226  0187     CLRF FSR1H
0227  3F40     MOVIW [0]FSR1
0228  00D0     MOVWF 0x50
0229  3F41     MOVIW [1]FSR1
022A  00D1     MOVWF 0x51
022B  0850     MOVF 0x50, W
022C  0084     MOVWF FSR0
022D  0851     MOVF 0x51, W
022E  0085     MOVWF FSR0H
022F  0800     MOVF INDF0, W
0230  00D2     MOVWF 0x52
0231  01D3     CLRF 0x53
0232  0852     MOVF 0x52, W
0233  00F1     MOVWF counter
0234  0853     MOVF 0x53, W
0235  00F2     MOVWF sign
0236  085F     MOVF fp, W
0237  00D4     MOVWF 0x54
0238  0854     MOVF 0x54, W
0239  00F3     MOVWF a
023A  318D     MOVLP 0xD
023B  255F     CALL 0x55F
023C  3181     MOVLP 0x1
1363:              ++*fmt;
023D  0140     MOVLB 0x0
023E  084E     MOVF fmt, W
023F  0086     MOVWF FSR1
0240  0187     CLRF FSR1H
0241  3001     MOVLW 0x1
0242  0781     ADDWF INDF1, F
0243  3141     ADDFSR 1, 1
0244  1803     BTFSC STATUS, 0x0
0245  0A81     INCF INDF1, F
0246  2A13     GOTO 0x213
1364:              return 1;
1365:          }
0247  0008     RETURN
1366:          #endif
1367:          
1368:          int vfprintf(FILE *fp, const char *fmt, va_list ap)
0D2E  0140     MOVLB 0x0
0D2F  00E5     MOVWF fp
1369:          {
1370:          #ifdef _VFPF_CONVERT
1371:              char *cfmt;
1372:          
1373:              cfmt = (char *)fmt;
0D30  0861     MOVF 0x61, W
0D31  00E7     MOVWF 0x67
0D32  0860     MOVF fmt, W
0D33  00E6     MOVWF cfmt
1374:              nout = 0;
0D34  0141     MOVLB 0x1
0D35  01CC     CLRF nout
0D36  01CD     CLRF 0xCD
1375:              while (*cfmt) {
0D37  2D4C     GOTO 0x54C
0D4C  0140     MOVLB 0x0
0D4D  0866     MOVF cfmt, W
0D4E  0084     MOVWF FSR0
0D4F  0867     MOVF 0x67, W
0D50  0085     MOVWF FSR0H
0D51  0012     MOVIW FSR0++
0D52  1D03     BTFSS STATUS, 0x2
0D53  2D55     GOTO 0x555
0D54  2D56     GOTO 0x556
0D55  2D38     GOTO 0x538
1376:                  nout += vfpfcnvrt(fp, &cfmt, ap);
0D38  3066     MOVLW 0x66
0D39  00E3     MOVWF 0x63
0D3A  0863     MOVF 0x63, W
0D3B  00CE     MOVWF fmt
0D3C  0862     MOVF ap, W
0D3D  00E4     MOVWF 0x64
0D3E  0864     MOVF 0x64, W
0D3F  00CF     MOVWF ap
0D40  0865     MOVF fp, W
0D41  3181     MOVLP 0x1
0D42  213A     CALL 0x13A
0D43  318D     MOVLP 0xD
0D44  0140     MOVLB 0x0
0D45  084E     MOVF fmt, W
0D46  0141     MOVLB 0x1
0D47  07CC     ADDWF nout, F
0D48  0140     MOVLB 0x0
0D49  084F     MOVF ap, W
0D4A  0141     MOVLB 0x1
0D4B  3DCD     ADDWFC 0xCD, F
1377:              }
1378:              return nout;
0D56  0141     MOVLB 0x1
0D57  084D     MOVF 0xCD, W
0D58  0140     MOVLB 0x0
0D59  00E1     MOVWF 0x61
0D5A  0141     MOVLB 0x1
0D5B  084C     MOVF nout, W
0D5C  0140     MOVLB 0x0
0D5D  00E0     MOVWF fmt
1379:          #else
1380:              return fputs(fmt, fp);
1381:          #endif
1382:          }
0D5E  0008     RETURN
---  /Applications/microchip/xc8/v2.20/pic/sources/c99/common/aomod.c  ----------------------------------
1:             // long long signed unsigned modulus
2:             
3:             #pragma warning disable 1516
4:             
5:             signed long long int
6:             #ifdef __PICC__
7:             __aomod(signed long long int divisor, signed long long int dividend)
8:             #else
9:             __aomod(signed long long int dividend, signed long long int divisor)
10:            #endif
11:            {
12:            	unsigned char	counter, sign;
13:            
14:            	sign = 0;
0F16  01F2     CLRF sign
15:            	if(dividend < 0) {
0F17  3028     MOVLW 0x28
0F18  0086     MOVWF FSR1
0F19  3000     MOVLW 0x0
0F1A  0087     MOVWF FSR1H
0F1B  3F47     MOVIW [7]FSR1
0F1C  00F0     MOVWF __pcstackCOMMON
0F1D  1FF0     BTFSS __pcstackCOMMON, 0x7
0F1E  2F20     GOTO 0x720
0F1F  2F21     GOTO 0x721
0F20  2F42     GOTO 0x742
16:            		dividend = -dividend;
0F21  0140     MOVLB 0x0
0F22  09A8     COMF dividend, F
0F23  09A9     COMF grs, F
0F24  09AA     COMF 0x2A, F
0F25  09AB     COMF cp, F
0F26  09AC     COMF 0x2C, F
0F27  09AD     COMF aexp, F
0F28  09AE     COMF bexp, F
0F29  09AF     COMF prod, F
0F2A  0AA8     INCF dividend, F
0F2B  1D03     BTFSS STATUS, 0x2
0F2C  2F40     GOTO 0x740
0F2D  0AA9     INCF grs, F
0F2E  1D03     BTFSS STATUS, 0x2
0F2F  2F40     GOTO 0x740
0F30  0AAA     INCF 0x2A, F
0F31  1D03     BTFSS STATUS, 0x2
0F32  2F40     GOTO 0x740
0F33  0AAB     INCF cp, F
0F34  1D03     BTFSS STATUS, 0x2
0F35  2F40     GOTO 0x740
0F36  0AAC     INCF 0x2C, F
0F37  1D03     BTFSS STATUS, 0x2
0F38  2F40     GOTO 0x740
0F39  0AAD     INCF aexp, F
0F3A  1D03     BTFSS STATUS, 0x2
0F3B  2F40     GOTO 0x740
0F3C  0AAE     INCF bexp, F
0F3D  1D03     BTFSS STATUS, 0x2
0F3E  2F40     GOTO 0x740
0F3F  0AAF     INCF prod, F
17:            		sign = 1;
0F40  01F2     CLRF sign
0F41  0AF2     INCF sign, F
18:            	}
19:            	if(divisor < 0)
0F42  3020     MOVLW 0x20
0F43  0086     MOVWF FSR1
0F44  3000     MOVLW 0x0
0F45  0087     MOVWF FSR1H
0F46  3F47     MOVIW [7]FSR1
0F47  00F0     MOVWF __pcstackCOMMON
0F48  1FF0     BTFSS __pcstackCOMMON, 0x7
0F49  2F4B     GOTO 0x74B
0F4A  2F4C     GOTO 0x74C
0F4B  2F6B     GOTO 0x76B
20:            		divisor = -divisor;
0F4C  0140     MOVLB 0x0
0F4D  09A0     COMF __pcstackBANK0, F
0F4E  09A1     COMF i, F
0F4F  09A2     COMF 0x22, F
0F50  09A3     COMF s, F
0F51  09A4     COMF b, F
0F52  09A5     COMF p, F
0F53  09A6     COMF 0x26, F
0F54  09A7     COMF i, F
0F55  0AA0     INCF __pcstackBANK0, F
0F56  1D03     BTFSS STATUS, 0x2
0F57  2F6B     GOTO 0x76B
0F58  0AA1     INCF i, F
0F59  1D03     BTFSS STATUS, 0x2
0F5A  2F6B     GOTO 0x76B
0F5B  0AA2     INCF 0x22, F
0F5C  1D03     BTFSS STATUS, 0x2
0F5D  2F6B     GOTO 0x76B
0F5E  0AA3     INCF s, F
0F5F  1D03     BTFSS STATUS, 0x2
0F60  2F6B     GOTO 0x76B
0F61  0AA4     INCF b, F
0F62  1D03     BTFSS STATUS, 0x2
0F63  2F6B     GOTO 0x76B
0F64  0AA5     INCF p, F
0F65  1D03     BTFSS STATUS, 0x2
0F66  2F6B     GOTO 0x76B
0F67  0AA6     INCF 0x26, F
0F68  1D03     BTFSS STATUS, 0x2
0F69  2F6B     GOTO 0x76B
0F6A  0AA7     INCF i, F
21:            	if(divisor != 0) {
0F6B  0140     MOVLB 0x0
0F6C  0820     MOVF __pcstackBANK0, W
0F6D  0421     IORWF i, W
0F6E  0422     IORWF 0x22, W
0F6F  0423     IORWF s, W
0F70  0424     IORWF b, W
0F71  0425     IORWF p, W
0F72  0426     IORWF 0x26, W
0F73  0427     IORWF i, W
0F74  1903     BTFSC STATUS, 0x2
0F75  2F77     GOTO 0x777
0F76  2F78     GOTO 0x778
0F77  2FCB     GOTO 0x7CB
22:            		counter = 1;
0F78  01F1     CLRF counter
0F79  0AF1     INCF counter, F
23:            		while((divisor & 0x8000000000000000ULL) == 0) {
0F7A  2F87     GOTO 0x787
0F87  1FA7     BTFSS i, 0x7
0F88  2F8A     GOTO 0x78A
0F89  2F8B     GOTO 0x78B
0F8A  2F7B     GOTO 0x77B
24:            			divisor <<= 1;
0F7B  35A0     LSLF __pcstackBANK0, F
0F7C  0DA1     RLF i, F
0F7D  0DA2     RLF 0x22, F
0F7E  0DA3     RLF s, F
0F7F  0DA4     RLF b, F
0F80  0DA5     RLF p, F
0F81  0DA6     RLF 0x26, F
0F82  0DA7     RLF i, F
25:            			counter++;
0F83  3001     MOVLW 0x1
0F84  00F0     MOVWF __pcstackCOMMON
0F85  0870     MOVF __pcstackCOMMON, W
0F86  07F1     ADDWF counter, F
26:            		}
27:            		do {
28:            			if((unsigned long long)divisor <= (unsigned long long)dividend)
0F8B  0827     MOVF i, W
0F8C  022F     SUBWF prod, W
0F8D  1D03     BTFSS STATUS, 0x2
0F8E  2FA9     GOTO 0x7A9
0F8F  0826     MOVF 0x26, W
0F90  022E     SUBWF bexp, W
0F91  1D03     BTFSS STATUS, 0x2
0F92  2FA9     GOTO 0x7A9
0F93  0825     MOVF p, W
0F94  022D     SUBWF aexp, W
0F95  1D03     BTFSS STATUS, 0x2
0F96  2FA9     GOTO 0x7A9
0F97  0824     MOVF b, W
0F98  022C     SUBWF 0x2C, W
0F99  1D03     BTFSS STATUS, 0x2
0F9A  2FA9     GOTO 0x7A9
0F9B  0823     MOVF s, W
0F9C  022B     SUBWF cp, W
0F9D  1D03     BTFSS STATUS, 0x2
0F9E  2FA9     GOTO 0x7A9
0F9F  0822     MOVF 0x22, W
0FA0  022A     SUBWF 0x2A, W
0FA1  1D03     BTFSS STATUS, 0x2
0FA2  2FA9     GOTO 0x7A9
0FA3  0821     MOVF i, W
0FA4  0229     SUBWF grs, W
0FA5  1D03     BTFSS STATUS, 0x2
0FA6  2FA9     GOTO 0x7A9
0FA7  0820     MOVF __pcstackBANK0, W
0FA8  0228     SUBWF dividend, W
0FA9  1C03     BTFSS STATUS, 0x0
0FAA  2FAC     GOTO 0x7AC
0FAB  2FAD     GOTO 0x7AD
0FAC  2FBD     GOTO 0x7BD
29:            				dividend -= divisor;
0FAD  0820     MOVF __pcstackBANK0, W
0FAE  02A8     SUBWF dividend, F
0FAF  0821     MOVF i, W
0FB0  3BA9     SUBWFB grs, F
0FB1  0822     MOVF 0x22, W
0FB2  3BAA     SUBWFB 0x2A, F
0FB3  0823     MOVF s, W
0FB4  3BAB     SUBWFB cp, F
0FB5  0824     MOVF b, W
0FB6  3BAC     SUBWFB 0x2C, F
0FB7  0825     MOVF p, W
0FB8  3BAD     SUBWFB aexp, F
0FB9  0826     MOVF 0x26, W
0FBA  3BAE     SUBWFB bexp, F
0FBB  0827     MOVF i, W
0FBC  3BAF     SUBWFB prod, F
30:            			*(unsigned long long int *)&divisor >>= 1;
0FBD  36A7     LSRF i, F
0FBE  0CA6     RRF 0x26, F
0FBF  0CA5     RRF p, F
0FC0  0CA4     RRF b, F
0FC1  0CA3     RRF s, F
0FC2  0CA2     RRF 0x22, F
0FC3  0CA1     RRF i, F
0FC4  0CA0     RRF __pcstackBANK0, F
31:            		} while(--counter != 0);
0FC5  3001     MOVLW 0x1
0FC6  02F1     SUBWF counter, F
0FC7  1D03     BTFSS STATUS, 0x2
0FC8  2FCA     GOTO 0x7CA
0FC9  2FCB     GOTO 0x7CB
0FCA  2F8B     GOTO 0x78B
32:            	}
33:            	if(sign)
0FCB  0872     MOVF sign, W
0FCC  1903     BTFSC STATUS, 0x2
0FCD  2FCF     GOTO 0x7CF
0FCE  2FD0     GOTO 0x7D0
0FCF  2FEE     GOTO 0x7EE
34:            		dividend = -dividend;
0FD0  09A8     COMF dividend, F
0FD1  09A9     COMF grs, F
0FD2  09AA     COMF 0x2A, F
0FD3  09AB     COMF cp, F
0FD4  09AC     COMF 0x2C, F
0FD5  09AD     COMF aexp, F
0FD6  09AE     COMF bexp, F
0FD7  09AF     COMF prod, F
0FD8  0AA8     INCF dividend, F
0FD9  1D03     BTFSS STATUS, 0x2
0FDA  2FEE     GOTO 0x7EE
0FDB  0AA9     INCF grs, F
0FDC  1D03     BTFSS STATUS, 0x2
0FDD  2FEE     GOTO 0x7EE
0FDE  0AAA     INCF 0x2A, F
0FDF  1D03     BTFSS STATUS, 0x2
0FE0  2FEE     GOTO 0x7EE
0FE1  0AAB     INCF cp, F
0FE2  1D03     BTFSS STATUS, 0x2
0FE3  2FEE     GOTO 0x7EE
0FE4  0AAC     INCF 0x2C, F
0FE5  1D03     BTFSS STATUS, 0x2
0FE6  2FEE     GOTO 0x7EE
0FE7  0AAD     INCF aexp, F
0FE8  1D03     BTFSS STATUS, 0x2
0FE9  2FEE     GOTO 0x7EE
0FEA  0AAE     INCF bexp, F
0FEB  1D03     BTFSS STATUS, 0x2
0FEC  2FEE     GOTO 0x7EE
0FED  0AAF     INCF prod, F
35:            	return dividend;
0FEE  0140     MOVLB 0x0
0FEF  0828     MOVF dividend, W
0FF0  00A0     MOVWF __pcstackBANK0
0FF1  0829     MOVF grs, W
0FF2  00A1     MOVWF i
0FF3  082A     MOVF 0x2A, W
0FF4  00A2     MOVWF 0x22
0FF5  082B     MOVF cp, W
0FF6  00A3     MOVWF s
0FF7  082C     MOVF 0x2C, W
0FF8  00A4     MOVWF b
0FF9  082D     MOVF aexp, W
0FFA  00A5     MOVWF p
0FFB  082E     MOVF bexp, W
0FFC  00A6     MOVWF 0x26
0FFD  082F     MOVF prod, W
0FFE  00A7     MOVWF i
36:            }
0FFF  0008     RETURN
---  /Applications/microchip/xc8/v2.20/pic/sources/c99/common/aodiv.c  ----------------------------------
1:             // long long signed unsigned division
2:             
3:             #pragma warning disable 1516
4:             
5:             signed long long int
6:             #ifdef __PICC__
7:             __aodiv(signed long long int divisor, signed long long int dividend)
8:             #else
9:             __aodiv(signed long long int dividend, signed long long int divisor)
10:            #endif
11:            {
12:            	signed long long int	quotient;
13:            	unsigned char	counter, sign;
14:            
15:            	sign = 0;
0039  01F2     CLRF sign
16:            	if(divisor < 0) {
003A  3020     MOVLW 0x20
003B  0086     MOVWF FSR1
003C  3000     MOVLW 0x0
003D  0087     MOVWF FSR1H
003E  3F47     MOVIW [7]FSR1
003F  00F0     MOVWF __pcstackCOMMON
0040  1FF0     BTFSS __pcstackCOMMON, 0x7
0041  2843     GOTO 0x43
0042  2844     GOTO 0x44
0043  2865     GOTO 0x65
17:            		divisor = -divisor;
0044  0140     MOVLB 0x0
0045  09A0     COMF __pcstackBANK0, F
0046  09A1     COMF i, F
0047  09A2     COMF 0x22, F
0048  09A3     COMF s, F
0049  09A4     COMF b, F
004A  09A5     COMF p, F
004B  09A6     COMF 0x26, F
004C  09A7     COMF i, F
004D  0AA0     INCF __pcstackBANK0, F
004E  1D03     BTFSS STATUS, 0x2
004F  2863     GOTO 0x63
0050  0AA1     INCF i, F
0051  1D03     BTFSS STATUS, 0x2
0052  2863     GOTO 0x63
0053  0AA2     INCF 0x22, F
0054  1D03     BTFSS STATUS, 0x2
0055  2863     GOTO 0x63
0056  0AA3     INCF s, F
0057  1D03     BTFSS STATUS, 0x2
0058  2863     GOTO 0x63
0059  0AA4     INCF b, F
005A  1D03     BTFSS STATUS, 0x2
005B  2863     GOTO 0x63
005C  0AA5     INCF p, F
005D  1D03     BTFSS STATUS, 0x2
005E  2863     GOTO 0x63
005F  0AA6     INCF 0x26, F
0060  1D03     BTFSS STATUS, 0x2
0061  2863     GOTO 0x63
0062  0AA7     INCF i, F
18:            		sign = 1;
0063  01F2     CLRF sign
0064  0AF2     INCF sign, F
19:            	}
20:            	if(dividend < 0) {
0065  3028     MOVLW 0x28
0066  0086     MOVWF FSR1
0067  3000     MOVLW 0x0
0068  0087     MOVWF FSR1H
0069  3F47     MOVIW [7]FSR1
006A  00F0     MOVWF __pcstackCOMMON
006B  1FF0     BTFSS __pcstackCOMMON, 0x7
006C  286E     GOTO 0x6E
006D  286F     GOTO 0x6F
006E  2892     GOTO 0x92
21:            		dividend = -dividend;
006F  0140     MOVLB 0x0
0070  09A8     COMF dividend, F
0071  09A9     COMF grs, F
0072  09AA     COMF 0x2A, F
0073  09AB     COMF cp, F
0074  09AC     COMF 0x2C, F
0075  09AD     COMF aexp, F
0076  09AE     COMF bexp, F
0077  09AF     COMF prod, F
0078  0AA8     INCF dividend, F
0079  1D03     BTFSS STATUS, 0x2
007A  288E     GOTO 0x8E
007B  0AA9     INCF grs, F
007C  1D03     BTFSS STATUS, 0x2
007D  288E     GOTO 0x8E
007E  0AAA     INCF 0x2A, F
007F  1D03     BTFSS STATUS, 0x2
0080  288E     GOTO 0x8E
0081  0AAB     INCF cp, F
0082  1D03     BTFSS STATUS, 0x2
0083  288E     GOTO 0x8E
0084  0AAC     INCF 0x2C, F
0085  1D03     BTFSS STATUS, 0x2
0086  288E     GOTO 0x8E
0087  0AAD     INCF aexp, F
0088  1D03     BTFSS STATUS, 0x2
0089  288E     GOTO 0x8E
008A  0AAE     INCF bexp, F
008B  1D03     BTFSS STATUS, 0x2
008C  288E     GOTO 0x8E
008D  0AAF     INCF prod, F
22:            		sign ^= 1;
008E  3001     MOVLW 0x1
008F  00F0     MOVWF __pcstackCOMMON
0090  0870     MOVF __pcstackCOMMON, W
0091  06F2     XORWF sign, F
23:            	}
24:            	quotient = 0;
0092  3073     MOVLW 0x73
0093  0086     MOVWF FSR1
0094  3000     MOVLW 0x0
0095  0087     MOVWF FSR1H
0096  3008     MOVLW 0x8
0097  00F0     MOVWF __pcstackCOMMON
0098  3000     MOVLW 0x0
0099  001E     MOVWI FSR1++
009A  0BF0     DECFSZ __pcstackCOMMON, F
009B  2899     GOTO 0x99
25:            	if(divisor != 0) {
009C  0140     MOVLB 0x0
009D  0820     MOVF __pcstackBANK0, W
009E  0421     IORWF i, W
009F  0422     IORWF 0x22, W
00A0  0423     IORWF s, W
00A1  0424     IORWF b, W
00A2  0425     IORWF p, W
00A3  0426     IORWF 0x26, W
00A4  0427     IORWF i, W
00A5  1903     BTFSC STATUS, 0x2
00A6  28A8     GOTO 0xA8
00A7  28A9     GOTO 0xA9
00A8  2905     GOTO 0x105
26:            		counter = 1;
00A9  01F1     CLRF counter
00AA  0AF1     INCF counter, F
27:            		while((divisor & 0x8000000000000000ULL) == 0) {
00AB  28B8     GOTO 0xB8
00B8  1FA7     BTFSS i, 0x7
00B9  28BB     GOTO 0xBB
00BA  28BC     GOTO 0xBC
00BB  28AC     GOTO 0xAC
28:            			divisor <<= 1;
00AC  35A0     LSLF __pcstackBANK0, F
00AD  0DA1     RLF i, F
00AE  0DA2     RLF 0x22, F
00AF  0DA3     RLF s, F
00B0  0DA4     RLF b, F
00B1  0DA5     RLF p, F
00B2  0DA6     RLF 0x26, F
00B3  0DA7     RLF i, F
29:            			counter++;
00B4  3001     MOVLW 0x1
00B5  00F0     MOVWF __pcstackCOMMON
00B6  0870     MOVF __pcstackCOMMON, W
00B7  07F1     ADDWF counter, F
30:            		}
31:            		do {
32:            			quotient <<= 1;
00BC  35F3     LSLF a, F
00BD  0DF4     RLF multiplicand, F
00BE  0DF5     RLF 0x75, F
00BF  0DF6     RLF b, F
00C0  0DF7     RLF 0x77, F
00C1  0DF8     RLF product, F
00C2  0DF9     RLF fp, F
00C3  0DFA     RLF 0x7A, F
33:            			if((unsigned long long)divisor <= (unsigned long long)dividend) {
00C4  0827     MOVF i, W
00C5  022F     SUBWF prod, W
00C6  1D03     BTFSS STATUS, 0x2
00C7  28E2     GOTO 0xE2
00C8  0826     MOVF 0x26, W
00C9  022E     SUBWF bexp, W
00CA  1D03     BTFSS STATUS, 0x2
00CB  28E2     GOTO 0xE2
00CC  0825     MOVF p, W
00CD  022D     SUBWF aexp, W
00CE  1D03     BTFSS STATUS, 0x2
00CF  28E2     GOTO 0xE2
00D0  0824     MOVF b, W
00D1  022C     SUBWF 0x2C, W
00D2  1D03     BTFSS STATUS, 0x2
00D3  28E2     GOTO 0xE2
00D4  0823     MOVF s, W
00D5  022B     SUBWF cp, W
00D6  1D03     BTFSS STATUS, 0x2
00D7  28E2     GOTO 0xE2
00D8  0822     MOVF 0x22, W
00D9  022A     SUBWF 0x2A, W
00DA  1D03     BTFSS STATUS, 0x2
00DB  28E2     GOTO 0xE2
00DC  0821     MOVF i, W
00DD  0229     SUBWF grs, W
00DE  1D03     BTFSS STATUS, 0x2
00DF  28E2     GOTO 0xE2
00E0  0820     MOVF __pcstackBANK0, W
00E1  0228     SUBWF dividend, W
00E2  1C03     BTFSS STATUS, 0x0
00E3  28E5     GOTO 0xE5
00E4  28E6     GOTO 0xE6
00E5  28F7     GOTO 0xF7
34:            				dividend -= divisor;
00E6  0820     MOVF __pcstackBANK0, W
00E7  02A8     SUBWF dividend, F
00E8  0821     MOVF i, W
00E9  3BA9     SUBWFB grs, F
00EA  0822     MOVF 0x22, W
00EB  3BAA     SUBWFB 0x2A, F
00EC  0823     MOVF s, W
00ED  3BAB     SUBWFB cp, F
00EE  0824     MOVF b, W
00EF  3BAC     SUBWFB 0x2C, F
00F0  0825     MOVF p, W
00F1  3BAD     SUBWFB aexp, F
00F2  0826     MOVF 0x26, W
00F3  3BAE     SUBWFB bexp, F
00F4  0827     MOVF i, W
00F5  3BAF     SUBWFB prod, F
35:            				quotient |= 1;
00F6  1473     BSF a, 0x0
36:            			}
37:            			*(unsigned long long int *)&divisor >>= 1;
00F7  36A7     LSRF i, F
00F8  0CA6     RRF 0x26, F
00F9  0CA5     RRF p, F
00FA  0CA4     RRF b, F
00FB  0CA3     RRF s, F
00FC  0CA2     RRF 0x22, F
00FD  0CA1     RRF i, F
00FE  0CA0     RRF __pcstackBANK0, F
38:            		} while(--counter != 0);
00FF  3001     MOVLW 0x1
0100  02F1     SUBWF counter, F
0101  1D03     BTFSS STATUS, 0x2
0102  2904     GOTO 0x104
0103  2905     GOTO 0x105
0104  28BC     GOTO 0xBC
39:            	}
40:            	if(sign)
0105  0872     MOVF sign, W
0106  1903     BTFSC STATUS, 0x2
0107  2909     GOTO 0x109
0108  290A     GOTO 0x10A
0109  2928     GOTO 0x128
41:            		quotient = -quotient;
010A  09F3     COMF a, F
010B  09F4     COMF multiplicand, F
010C  09F5     COMF 0x75, F
010D  09F6     COMF b, F
010E  09F7     COMF 0x77, F
010F  09F8     COMF product, F
0110  09F9     COMF fp, F
0111  09FA     COMF 0x7A, F
0112  0AF3     INCF a, F
0113  1D03     BTFSS STATUS, 0x2
0114  2928     GOTO 0x128
0115  0AF4     INCF multiplicand, F
0116  1D03     BTFSS STATUS, 0x2
0117  2928     GOTO 0x128
0118  0AF5     INCF 0x75, F
0119  1D03     BTFSS STATUS, 0x2
011A  2928     GOTO 0x128
011B  0AF6     INCF b, F
011C  1D03     BTFSS STATUS, 0x2
011D  2928     GOTO 0x128
011E  0AF7     INCF 0x77, F
011F  1D03     BTFSS STATUS, 0x2
0120  2928     GOTO 0x128
0121  0AF8     INCF product, F
0122  1D03     BTFSS STATUS, 0x2
0123  2928     GOTO 0x128
0124  0AF9     INCF fp, F
0125  1D03     BTFSS STATUS, 0x2
0126  2928     GOTO 0x128
0127  0AFA     INCF 0x7A, F
42:            	return quotient;
0128  0873     MOVF a, W
0129  0140     MOVLB 0x0
012A  00A0     MOVWF __pcstackBANK0
012B  0874     MOVF multiplicand, W
012C  00A1     MOVWF i
012D  0875     MOVF 0x75, W
012E  00A2     MOVWF 0x22
012F  0876     MOVF b, W
0130  00A3     MOVWF s
0131  0877     MOVF 0x77, W
0132  00A4     MOVWF b
0133  0878     MOVF product, W
0134  00A5     MOVWF p
0135  0879     MOVF fp, W
0136  00A6     MOVWF 0x26
0137  087A     MOVF 0x7A, W
0138  00A7     MOVWF i
43:            }
0139  0008     RETURN
---  /Applications/microchip/xc8/v2.20/pic/sources/c99/common/abs.c  ------------------------------------
1:             int abs(int a)
2:             {
3:             	return a>0 ? a : -a;
0C84  0874     MOVF multiplicand, W
0C85  3A80     XORLW 0x80
0C86  00F5     MOVWF 0x75
0C87  3080     MOVLW 0x80
0C88  0275     SUBWF 0x75, W
0C89  1D03     BTFSS STATUS, 0x2
0C8A  2C8D     GOTO 0x48D
0C8B  3001     MOVLW 0x1
0C8C  0273     SUBWF a, W
0C8D  1803     BTFSC STATUS, 0x0
0C8E  2C90     GOTO 0x490
0C8F  2C91     GOTO 0x491
0C90  2C9D     GOTO 0x49D
0C91  0973     COMF a, W
0C92  00F5     MOVWF 0x75
0C93  0974     COMF multiplicand, W
0C94  00F6     MOVWF b
0C95  0AF5     INCF 0x75, F
0C96  1903     BTFSC STATUS, 0x2
0C97  0AF6     INCF b, F
0C98  0875     MOVF 0x75, W
0C99  00F3     MOVWF a
0C9A  0876     MOVF b, W
0C9B  00F4     MOVWF multiplicand
0C9C  2C9D     GOTO 0x49D
4:             }
0C9D  0008     RETURN
---  /Applications/microchip/xc8/v2.20/pic/sources/c99/common/Umul8_16.c  -------------------------------
1:             // 8 x 8 bit multiplication with 16 bit result
2:             #include <stdint.h>
3:             uint16_t
4:             _Umul8_16(unsigned char multiplier, unsigned char multiplicand) {
0CBD  00F8     MOVWF product
5:             	uint16_t product = 0;
0CBE  01F4     CLRF multiplicand
0CBF  01F5     CLRF 0x75
6:             	uint16_t word_mpld = (uint16_t) multiplicand;
0CC0  0870     MOVF __pcstackCOMMON, W
0CC1  00F2     MOVWF sign
0CC2  01F3     CLRF a
0CC3  0872     MOVF sign, W
0CC4  00F6     MOVWF b
0CC5  0873     MOVF a, W
0CC6  00F7     MOVWF 0x77
7:             
8:             #if defined(__OPTIMIZE_SPEED__)
9:             
10:            	if (multiplier & 0x01) {
11:            		product += word_mpld;
12:            	}
13:            	word_mpld <<= 1;
14:            
15:            	if (multiplier & 0x02) {
16:            		product += word_mpld;
17:            	}
18:            	word_mpld <<= 1;
19:            
20:            	if (multiplier & 0x04) {
21:            		product += word_mpld;
22:            	}
23:            	word_mpld <<= 1;
24:            
25:            	if (multiplier & 0x08) {
26:            		product += word_mpld;
27:            	}
28:            	word_mpld <<= 1;
29:            
30:            	if (multiplier & 0x10) {
31:            		product += word_mpld;
32:            	}
33:            	word_mpld <<= 1;
34:            
35:            	if (multiplier & 0x20) {
36:            		product += word_mpld;
37:            	}
38:            	word_mpld <<= 1;
39:            
40:            	if (multiplier & 0x40) {
41:            		product += word_mpld;
42:            	}
43:            	word_mpld <<= 1;
44:            
45:            	if (multiplier & 0x80) {
46:            		product += word_mpld;
47:            	}
48:            
49:            #else
50:            	do {
51:            		if (multiplier & 1) {
0CC7  1C78     BTFSS product, 0x0
0CC8  2CCA     GOTO 0x4CA
0CC9  2CCB     GOTO 0x4CB
0CCA  2CCF     GOTO 0x4CF
52:            			product += word_mpld;
0CCB  0876     MOVF b, W
0CCC  07F4     ADDWF multiplicand, F
0CCD  0877     MOVF 0x77, W
0CCE  3DF5     ADDWFC 0x75, F
53:            		}
54:            		word_mpld <<= 1;
0CCF  3001     MOVLW 0x1
0CD0  35F6     LSLF b, F
0CD1  0DF7     RLF 0x77, F
0CD2  0B89     DECFSZ WREG, F
0CD3  2CD0     GOTO 0x4D0
55:            		multiplier >>= 1;
0CD4  1003     BCF STATUS, 0x0
0CD5  0CF8     RRF product, F
56:            	} while (multiplier != 0);
0CD6  0878     MOVF product, W
0CD7  1D03     BTFSS STATUS, 0x2
0CD8  2CDA     GOTO 0x4DA
0CD9  2CDB     GOTO 0x4DB
0CDA  2CC7     GOTO 0x4C7
57:            
58:            #endif
59:            	return product;
0CDB  0875     MOVF 0x75, W
0CDC  00F1     MOVWF counter
0CDD  0874     MOVF multiplicand, W
0CDE  00F0     MOVWF __pcstackCOMMON
60:            }
0CDF  0008     RETURN
---  /Applications/microchip/xc8/v2.20/pic/sources/c99/common/Umul32.c  ---------------------------------
1:             // 32 x 32 bit multiplication with 32 bit result
2:             #ifdef _PIC18
3:             #define _Has_hardware_multiply 1
4:             #else
5:             #define _Has_hardware_multiply 0
6:             #endif
7:             
8:             #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:             #define _Has_large_call_stack 1
10:            #else
11:            #define _Has_large_call_stack 0
12:            #endif
13:            
14:            unsigned long
15:            __lmul(unsigned long multiplier, unsigned long multiplicand)
16:            {
17:            	unsigned long product;
18:            
19:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
20:            #define LMIDBYTE(x) (*(((unsigned char *)(&x))+1))
21:            #define HMIDBYTE(x) (*(((unsigned char *)(&x))+2))
22:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+3))
23:            
24:            #if (_Has_hardware_multiply || _Has_large_call_stack) && defined(__OPTIMIZE_SPEED__)
25:            	{
26:            
27:            #define USE_SHRINK
28:            
29:            /*
30:            a 32-bit multiply can be decomposed into the sum of ten 8-bit multiplies
31:                         a  b  c  d
32:            *            e  f  g  h
33:            -----------------------
34:                       |         dh
35:                       |      ch  0
36:                       |   bh  0  0
37:                       |ah  0  0  0
38:                       |      dg  0
39:                       |   cg  0  0
40:                       |bg  0  0  0
41:                     ag| 0  0  0  0 (we ignore this intermediate product
42:                                     because it does not affect the low 32 bits of the result)
43:                       |   df  0  0
44:                       |cf  0  0  0
45:                     bf| 0  0  0  0 (ignore)
46:                  af  0| 0  0  0  0 (ignore)
47:                       |de  0  0  0
48:                     ce| 0  0  0  0 (ignore)
49:                  be  0| 0  0  0  0 (ignore)
50:            +  ae  0  0| 0  0  0  0 (ignore)
51:            =======================
52:             */
53:            		product =  (unsigned int)LOWBYTE(multiplier) * LOWBYTE(multiplicand);
54:            
55:            #if defined(USE_MASKS)
56:            		product += ((unsigned long)
57:            			     ((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand))
58:            			     +
59:            			     ((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
60:            			<< 8;
61:            
62:            		product += ((unsigned long)
63:            			    ((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand))
64:            			    +
65:            			    ((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
66:            			    +
67:            			    ((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
68:            			<< 16;
69:            
70:            		/* cast to smaller type to avoid adding high bits just to discard */
71:            		product += ((unsigned long)
72:            			    (unsigned char)
73:            			    ((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand))
74:            			    +
75:            			    (unsigned char)
76:            			    ((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand))
77:            			    +
78:            			    (unsigned char)
79:            			    ((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
80:            			    +
81:            			    (unsigned char)
82:            			    ((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand)))
83:            			<< 24;
84:            
85:            #elif defined(USE_SHRINK)
86:            		/* add direct to upper bytes, rather than shift and add all bytes */
87:            		*((__uint24 *)(((unsigned char*)&product)+1)) +=
88:            			((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand));
89:            		*((__uint24 *)(((unsigned char*)&product)+1)) +=
90:            			((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand));
91:            
92:            
93:            		*((unsigned int*)(((unsigned char*)&product)+2)) +=
94:            			((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand));
95:            		*((unsigned int*)(((unsigned char*)&product)+2)) +=
96:            			((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
97:            		*((unsigned int*)(((unsigned char*)&product)+2)) +=
98:            			((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand));
99:            
100:           		*(((unsigned char*)&product)+3) +=
101:           			(unsigned char)
102:           			((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand));
103:           		*(((unsigned char*)&product)+3) +=
104:           			(unsigned char)
105:           			((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand));
106:           		*(((unsigned char*)&product)+3) +=
107:           			(unsigned char)
108:           			((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
109:           		*(((unsigned char*)&product)+3) +=
110:           			(unsigned char)
111:           			((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand));
112:           
113:           #else
114:           #error No method chosen
115:           #endif
116:           	}
117:           #else
118:           
119:           	product = 0;
0006  3000     MOVLW 0x0
0007  00FB     MOVWF 0x7B
0008  3000     MOVLW 0x0
0009  00FA     MOVWF 0x7A
000A  3000     MOVLW 0x0
000B  00F9     MOVWF fp
000C  3000     MOVLW 0x0
000D  00F8     MOVWF product
120:           	do {
121:           		if(multiplier & 1)
000E  1C70     BTFSS __pcstackCOMMON, 0x0
000F  2811     GOTO 0x11
0010  2812     GOTO 0x12
0011  281A     GOTO 0x1A
122:           			product += multiplicand;
0012  0874     MOVF multiplicand, W
0013  07F8     ADDWF product, F
0014  0875     MOVF 0x75, W
0015  3DF9     ADDWFC fp, F
0016  0876     MOVF b, W
0017  3DFA     ADDWFC 0x7A, F
0018  0877     MOVF 0x77, W
0019  3DFB     ADDWFC 0x7B, F
123:           		multiplicand <<= 1;
001A  3001     MOVLW 0x1
001B  35F4     LSLF multiplicand, F
001C  0DF5     RLF 0x75, F
001D  0DF6     RLF b, F
001E  0DF7     RLF 0x77, F
001F  0B89     DECFSZ WREG, F
0020  281B     GOTO 0x1B
124:           		multiplier >>= 1;
0021  3001     MOVLW 0x1
0022  36F3     LSRF a, F
0023  0CF2     RRF sign, F
0024  0CF1     RRF counter, F
0025  0CF0     RRF __pcstackCOMMON, F
0026  0B89     DECFSZ WREG, F
0027  2822     GOTO 0x22
125:           	} while(multiplier != 0);
0028  0873     MOVF a, W
0029  0472     IORWF sign, W
002A  0471     IORWF counter, W
002B  0470     IORWF __pcstackCOMMON, W
002C  1D03     BTFSS STATUS, 0x2
002D  282F     GOTO 0x2F
002E  2830     GOTO 0x30
002F  280E     GOTO 0xE
126:           
127:           #endif
128:           	return product;
0030  087B     MOVF 0x7B, W
0031  00F3     MOVWF a
0032  087A     MOVF 0x7A, W
0033  00F2     MOVWF sign
0034  0879     MOVF fp, W
0035  00F1     MOVWF counter
0036  0878     MOVF product, W
0037  00F0     MOVWF __pcstackCOMMON
129:           }
0038  0008     RETURN
---  /Applications/microchip/xc8/v2.20/pic/sources/c99/common/Umul16.c  ---------------------------------
1:             // 16 x 16 bit multiplication with 16 bit result
2:             #ifdef _PIC18
3:             #define _Has_hardware_multiply 1
4:             #else
5:             #define _Has_hardware_multiply 0
6:             #endif
7:             
8:             #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:             #define _Has_large_call_stack 1
10:            #else
11:            #define _Has_large_call_stack 0
12:            #endif
13:            
14:            unsigned int
15:            __wmul(unsigned int multiplier, unsigned int multiplicand)
16:            {
17:                    unsigned int product;
18:            
19:            #if _Has_hardware_multiply || _Has_large_call_stack
20:            
21:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
22:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
23:            
24:            	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
25:            /*
26:            a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
27:                   a  b
28:            *      c  d
29:            -----------
30:                 |   bd
31:                 |ad  0
32:                 |bc  0
33:            +  ac| 0  0 (we ignore this intermediate product
34:                         because it does not affect the low 16 bits of the result)
35:            ===========
36:             */
37:                    product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
38:                    product += (LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
39:                    product += (HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
40:            
41:            #else
42:            
43:            	product = 0;
0C9E  01F4     CLRF multiplicand
0C9F  01F5     CLRF 0x75
44:            	do {
45:            		if(multiplier & 1)
0CA0  1C70     BTFSS __pcstackCOMMON, 0x0
0CA1  2CA3     GOTO 0x4A3
0CA2  2CA4     GOTO 0x4A4
0CA3  2CA8     GOTO 0x4A8
46:            			product += multiplicand;
0CA4  0872     MOVF sign, W
0CA5  07F4     ADDWF multiplicand, F
0CA6  0873     MOVF a, W
0CA7  3DF5     ADDWFC 0x75, F
47:            		multiplicand <<= 1;
0CA8  3001     MOVLW 0x1
0CA9  35F2     LSLF sign, F
0CAA  0DF3     RLF a, F
0CAB  0B89     DECFSZ WREG, F
0CAC  2CA9     GOTO 0x4A9
48:            		multiplier >>= 1;
0CAD  3001     MOVLW 0x1
0CAE  36F1     LSRF counter, F
0CAF  0CF0     RRF __pcstackCOMMON, F
0CB0  0B89     DECFSZ WREG, F
0CB1  2CAE     GOTO 0x4AE
49:            	} while(multiplier != 0);
0CB2  0870     MOVF __pcstackCOMMON, W
0CB3  0471     IORWF counter, W
0CB4  1D03     BTFSS STATUS, 0x2
0CB5  2CB7     GOTO 0x4B7
0CB6  2CB8     GOTO 0x4B8
0CB7  2CA0     GOTO 0x4A0
50:            
51:            #endif
52:                    return product;
0CB8  0875     MOVF 0x75, W
0CB9  00F1     MOVWF counter
0CBA  0874     MOVF multiplicand, W
0CBB  00F0     MOVWF __pcstackCOMMON
53:            }
0CBC  0008     RETURN
