Disassembly Listing for mcu-irq-benchmark
Generated From:
/Users/Dennis/Documents/design.projects/thinkific.cool-mcu.com/github/mcu-tips-n-tricks/mcu-irq-benchmark/mcu-irq-benchmark.X/dist/PIC24FJ1024GA606_BH/production/mcu-irq-benchmark.X.production.elf
Sep 20, 2020 10:09:29 AM

---  /Users/Dennis/Documents/design.projects/thinkific.cool-mcu.com/github/mcu-tips-n-tricks/mcu-irq-benchmark/mcu-irq-benchmark.X/main.c
1:                 /*******************************************************************************
2:                  * Copyright (c) 2020 dBm Signal Dynamics Inc.
3:                  * 
4:                  * File:        main.c
5:                  * Project:     mcu-irq-benchmark
6:                  * Compiler:    XC8 v2.20, XC16 v1.60, XC32 v2.41
7:                  * Hardware:    PIC16F19197 Basic Hookup (Schematic #14-00058A)
8:                  *              PIC24FJ1024GA606 Basic Hookup (Schematic #14-00059A)
9:                  *              PIC32MZ1024EFH064 Basic Hookup (Schematic #14-00060A)
10:                 * 
11:                 * Project used to measure the latency between interrupt assertion and the first
12:                 * instruction executed in the ISR for all 3 MCUs. An Oscilloscope is required.
13:                 * 
14:                 * Project produces a 1 kHz, 50% duty-cycle PWM output signal (and IRQ),
15:                 * The IRQ's ISR routine toggles a digital output pin (USER LED pin).
16:                 * 
17:                 * An Oscilloscope is used to measure IRQ latency (PWM 0-->1 to LED toggle).
18:                 * 
19:                 * The Disassembly listing must be consulted to subtract the #instruction cycles
20:                 * used to toggle the USER LED. 
21:                 * 
22:                 * SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
23:                 * EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
24:                 * MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
25:                 * IN NO EVENT SHALL DBM SIGNAL DYNAMICS OR ITS LICENSORS BE LIABLE OR OBLIGATED
26:                 * UNDER CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY,
27:                 * OR OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
28:                 * INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
29:                 * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
30:                 * SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
31:                 * (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
32:                *******************************************************************************/
33:                #include <xc.h>
34:                #include <stdint.h>
35:                #include <stdio.h>
36:                #include "configBits.h"     // Hardware Configuration bit settings
37:                
38:                #if defined(PIC16F19197_BH)
39:                #define ELAPSED_TICKS_ADJUSTMENT 9
40:                #define NoOP() NOP()                        // Define macro for NOP assembly instruction
41:                #define MAX_LOOP_COUNT  1
42:                #elif defined(PIC24FJ1024GA606_BH)
43:                #include <libpic30.h>                       // Added for printf() --> UART2 redirect support
44:                #define ELAPSED_TICKS_ADJUSTMENT 10         // Timer Tick Adjustment for reading the timer register
45:                #define NoOP() Nop()                        // Define macro for NOP assembly instruction
46:                #define MAX_LOOP_COUNT  1
47:                #elif defined(PIC32MZ1024EFH064_BH)
48:                #include <cp0defs.h>                        // CP0 access macros for PIC32M devices
49:                #define ELAPSED_TICKS_ADJUSTMENT 12         // Timer Tick Adjustment for reading the timer register
50:                #define NoOP() Nop()                        // Define macro for NOP assembly instruction
51:                #define MAX_LOOP_COUNT  4
52:                #endif
53:                
54:                // Global Variables
55:                
56:                const char Project[] = "mcu-irq-benchmark";
57:                const char Version[] = "00.01";
58:                const char CompileDate[] = __DATE__;
59:                const char CompileTime[] = __TIME__;
60:                
61:                
62:                // Local Function Prototypes
63:                void Initiallize(void);                     // 1-time System Initialization
64:                void SetPerformanceMode(void);              // Configure Clocks, Interrupts, Cache, Pre-fetch for desired performance
65:                void PinConfig(void);                       // Configure Programmable I/O pins
66:                void UartConfig(void);                      // Configure UART for printf() statement
67:                void PWMConfig(void);                       // Configure a PWM resource to produce a 1 kHz signal (and irq) on selected output pin
68:                
69:                int main(void) {
000E42  FA0000     LNK #0x0
70:                    
71:                    Initiallize();
000E44  070001     RCALL Initiallize
72:                    
73:                    while(1);
000E46  37FFFF     BRA .L2
74:                  
75:                }
76:                
77:                void Initiallize(void){
000E48  FA0000     LNK #0x0
78:                    
79:                    // Configure Clocks, Interrupts, Cache, Pre-fetch for desired performance
80:                    SetPerformanceMode();       
000E4A  070022     RCALL SetPerformanceMode
81:                    
82:                    // Configure Programmable I/O Pins for all I/O in this application
83:                    PinConfig();
000E4C  070029     RCALL PinConfig
84:                    
85:                    // Configure UART resource for printf() statement
86:                    UartConfig();
000E4E  070050     RCALL UartConfig
87:                    
88:                    printf("Cool-MCU.com\r\n");
000E50  28DF30     MOV #0x8DF3, W0
000E52  07FA6A     RCALL _puts
89:                    printf("Project: %s\r\n", Project);
000E54  28DC60     MOV #0x8DC6, W0
000E56  781F80     MOV W0, [W15++]
000E58  28E010     MOV #0x8E01, W0
000E5A  781F80     MOV W0, [W15++]
000E5C  07FBF5     RCALL __dprintf_s, __dprintf_0
000E5E  5787E4     SUB W15, #0x4, W15
90:                    printf("Version: %s\r\n", Version);
000E60  28DD80     MOV #0x8DD8, W0
000E62  781F80     MOV W0, [W15++]
000E64  28E0F0     MOV #0x8E0F, W0
000E66  781F80     MOV W0, [W15++]
000E68  07FBEF     RCALL __dprintf_s, __dprintf_0
000E6A  5787E4     SUB W15, #0x4, W15
91:                    printf("Build date: %s\r\n", CompileDate);
000E6C  28DDE0     MOV #0x8DDE, W0
000E6E  781F80     MOV W0, [W15++]
000E70  28E1D0     MOV #0x8E1D, W0
000E72  781F80     MOV W0, [W15++]
000E74  07FBE9     RCALL __dprintf_s, __dprintf_0
000E76  5787E4     SUB W15, #0x4, W15
92:                    printf("Build time: %s\r\n\r\n", CompileTime);
000E78  28DEA0     MOV #0x8DEA, W0
000E7A  781F80     MOV W0, [W15++]
000E7C  28E2E0     MOV #0x8E2E, W0
000E7E  781F80     MOV W0, [W15++]
000E80  07FBE3     RCALL __dprintf_s, __dprintf_0
000E82  5787E4     SUB W15, #0x4, W15
93:                
94:                    // Configure a PWM resource to produce a 50% duty cycle, 1 kHz signal (and interrupt)
95:                    PWMConfig();
000E84  070041     RCALL PWMConfig
96:                    
97:                    // Configure LED output
98:                
99:                #if defined(PIC16F19197_BH)
100:               
101:                   ANSELEbits.ANSE5 = 0;
102:                   TRISEbits.TRISE5 = 0;
103:                   LATEbits.LATE5 = 0;
104:               
105:               #elif defined(PIC24FJ1024GA606_BH)
106:                   
107:                   TRISEbits.TRISE2 = 0;
000E86  A946B2     BCLR TRISE, #2
108:                   LATEbits.LATE2 = 0;
000E88  A946B6     BCLR LATE, #2
109:                   
110:               #endif      
111:                   
112:                   // Enable Interrupts Globally
113:               
114:               #if defined(PIC16F19197_BH)
115:                   
116:                   INTCONbits.PEIE = 1;    // Enable all peripheral interrupt sources
117:                   INTCONbits.GIE = 1;     // Enable interrupts globally    
118:               
119:               #elif defined(PIC24FJ1024GA606_BH)
120:                   
121:                   INTCON2bits.GIE = 1;    // Enable interrupts globally
000E8A  A8E083     BSET 0x83, #7
122:                   
123:               #endif    
124:                   
125:                   
126:               }
000E8C  FA8000     ULNK
000E8E  060000     RETURN
127:               
128:               void SetPerformanceMode(void) {
000E90  FA0000     LNK #0x0
129:                   
130:                   // At this point, the CPU is operating using the default oscillator and
131:                   // clocking options defined by the hardware configuration bits.
132:                   
133:                   // Add any code below to adjust clocks and any other configuration for
134:                   // desired performance before running your main code loop.
135:                   
136:               #if defined(PIC32MZ1024EFH064_BH)
137:                   
138:                   // At this point, the Hardware Clock Initialization is Complete
139:               	// The Primary External XTAL OSC Oscillator Circuit (8 MHz) provides the clock source
140:               	// Instruction Clock, PBCLK7 (SYSCLK) set to 8 MHz
141:                   // Peripheral Bus Clocks divisors set to defaults (divide by 2))
142:                   // Flash memory predictive prefetch is disabled
143:                   // Cache memory is enabled (per compiler default XC32 startup setting)
144:                   // Interrupt controller is in single vector mode (per compiler default XC32 startup setting)
145:                   // Interrupts are disabled (per compiler default XC32 startup setting)
146:                   
147:                   // Set the desired performance mode:
148:                   // SYSCLK = 8 MHz, All PBCLKx = 8 MHz
149:                   // Cache Enabled (per default setting in "pic32_init_cache.S" - _CACHE_WRITEBACK_WRITEALLOCATE)
150:                   // Pre-Fetch Enabled
151:                   
152:                   unsigned int cp0;
153:               	
154:                   // Unlock Sequence
155:                   asm volatile("di");     // disable all interrupts
156:                   SYSKEY = 0xAA996655;
157:                   SYSKEY = 0x556699AA;  
158:               
159:                   // PB1DIV
160:                                           // Peripheral Bus 1 cannot be turned off, so there's no need to turn it on
161:                   PB1DIVbits.PBDIV = 0;   // Peripheral Bus 1 Clock Divisor Control (PBCLK1 is SYSCLK divided by 1)
162:               
163:                   // PB2DIV
164:                   PB2DIVbits.ON = 1;      // Peripheral Bus 2 Output Clock Enable (Output clock is enabled)
165:                   PB2DIVbits.PBDIV = 0;   // Peripheral Bus 2 Clock Divisor Control (PBCLK2 is SYSCLK divided by 1)
166:               
167:                   // PB3DIV
168:                   PB3DIVbits.ON = 1;      // Peripheral Bus 2 Output Clock Enable (Output clock is enabled)
169:                   PB3DIVbits.PBDIV = 0;   // Peripheral Bus 3 Clock Divisor Control (PBCLK3 is SYSCLK divided by 1)
170:               
171:                   // PB4DIV
172:                   PB4DIVbits.ON = 1;      // Peripheral Bus 4 Output Clock Enable (Output clock is enabled)
173:                   while (!PB4DIVbits.PBDIVRDY); // Wait until it is ready to write to
174:                   PB4DIVbits.PBDIV = 0;   // Peripheral Bus 4 Clock Divisor Control (PBCLK4 is SYSCLK divided by 1)
175:               
176:                   // PB5DIV
177:                   PB5DIVbits.ON = 1;      // Peripheral Bus 5 Output Clock Enable (Output clock is enabled)
178:                   PB5DIVbits.PBDIV = 0;   // Peripheral Bus 5 Clock Divisor Control (PBCLK5 is SYSCLK divided by 1)
179:               
180:                   // PB7DIV
181:                   PB7DIVbits.ON = 1;      // Peripheral Bus 7 Output Clock Enable (Output clock is enabled)
182:                   PB7DIVbits.PBDIV = 0;   // Peripheral Bus 7 Clock Divisor Control (PBCLK7 is SYSCLK divided by 1)
183:               
184:                   // PB8DIV
185:                   PB8DIVbits.ON = 1;      // Peripheral Bus 8 Output Clock Enable (Output clock is enabled)
186:                   PB8DIVbits.PBDIV = 0;   // Peripheral Bus 8 Clock Divisor Control (PBCLK8 is SYSCLK divided by 1)
187:               
188:                   // PRECON - Set up prefetch (60 MHz operation))
189:                   //PRECONbits.PFMSECEN = 0; // Flash SEC Interrupt Enable (Do not generate an interrupt when the PFMSEC bit is set)
190:                   PRECONbits.PREFEN = 0b11; // Predictive Prefetch Enable (Enable predictive prefetch for any address)
191:                   PRECONbits.PFMWS = 0b000; // PFM Access Time Defined in Terms of SYSCLK Wait States (Zero wait states @ 8 MHz)
192:               
193:                   // Set up caching
194:                   // See  https://microchipdeveloper.com/32bit:mz-cache-disable
195:                   // Added "pic32_init_cache.S" to project from XC32 tool chain, and set __PIC32_CACHE_MODE to _CACHE_WRITEBACK_WRITEALLOCATE
196:               
197:                   // Lock Sequence
198:                   SYSKEY = 0x33333333;
199:                   asm volatile("ei");     // Enable all interrupts    
200:                   
201:               #elif defined(PIC24FJ1024GA606_BH)
202:                   
203:                   // At this point, the Hardware Clock Initialization is Complete
204:                   // Primary OSC with 4X PLL provides 32 MHz Fosc (16 MIPs)
205:                   
206:                   // Need to set Fosc to 16 MHz (8 MIPs)
207:                   
208:                   CLKDIVbits.CPDIV = 0x01;    // Select DIV2 clock scaling (16 MHz, 8 MIPs)    
000E92  800811     MOV CLKDIV, W1
000E94  2FF3F0     MOV #0xFF3F, W0
000E96  608000     AND W1, W0, W0
000E98  A06000     BSET W0, #6
000E9A  880810     MOV W0, CLKDIV
209:                   
210:               #endif
211:                   
212:               }
000E9C  FA8000     ULNK
000E9E  060000     RETURN
213:               
214:               void PinConfig(void){
000EA0  FA0000     LNK #0x0
215:                       
216:               #if defined(PIC16F19197_BH)
217:                   
218:                   // Configure digital pins for UART function
219:                   TRISCbits.TRISC7 = 0;       // TX1 --> RC7
220:                   TRISCbits.TRISC6 = 1;       // RX1 <-- RC6
221:                   
222:                   // RE6 used as CCP1 PWM output signal
223:                   // Make pin digital
224:                   ANSELEbits.ANSE6 = 0;
225:                   // Make pin digital output and initialize level
226:                   TRISEbits.TRISE6 = 0;
227:                   LATEbits.LATE6 = 0;
228:                   
229:                   // Initiallize PPS Pin Mapping for this Application
230:                   // TX1 --> RC7 
231:                   // RX1 <-- RC6
232:                   // CCP1 --> RE6
233:                   // 1. Unlock PPS registers
234:                   //bit oldGIE = INTCONbits.GIE;
235:                   //INTCONbits.GIE = 0;
236:                   PPSLOCK = 0x55;
237:                   PPSLOCK = 0xAA;
238:                   PPSLOCKbits.PPSLOCKED = 0;
239:                   //INTCONbits.GIE = oldGIE;
240:                   // 2. Configure Output Functions
241:                   // Assign TX1 output function to pin RC7
242:                   RC7PPS = 0x0D;
243:                   // Assign CCP1 output function to pin RE6
244:                   RE6PPS = 0x09;
245:                   // 3. Configure Input Functions
246:                   // Assign RC6 pin to RX1 input function
247:                   RX1PPS = 0x16;
248:                   // 4 Lock the PPS registers
249:                   //oldGIE = INTCONbits.GIE;
250:                   //INTCONbits.GIE = 0;
251:                   PPSLOCK = 0x55;
252:                   PPSLOCK = 0xAA;
253:                   PPSLOCKbits.PPSLOCKED = 1;
254:                   //INTCONbits.GIE = oldGIE;
255:                   
256:               #elif defined(PIC24FJ1024GA606_BH)
257:                   
258:                   // RD0 used as OC1 PWM output signal
259:                   // Make pin digital
260:                   // ANSELEbits.ANSE6 = 0;
261:                   // Make pin digital output and initialize level
262:                   TRISDbits.TRISD0 = 0;
000EA2  A9069E     BCLR TRISD, #0
263:                   LATDbits.LATD0 = 0;
000EA4  A906A2     BCLR LATD, #0
264:                   
265:                   // Set up PPS (I/O Pin-Mapping) for all I/O in this application
266:                   // U2RX <-- RP10/RF4   (DEBUG PORT PC-TX pin)
267:                   // U2TX --> RP17/RF5   (DEBUG PORT PC-RX pin)
268:                   // OC1 --> RP11/RD0     1 kHz PWM output
269:                   // 1. Unlock PPS registers
270:                   __builtin_write_OSCCONL(OSCCON & 0xBF);
000EA6  800801     MOV OSCCON, W1
000EA8  200BF0     MOV #0xBF, W0
000EAA  608100     AND W1, W0, W2
000EAC  200460     MOV #0x46, W0
000EAE  200571     MOV #0x57, W1
000EB0  201003     MOV #0x100, W3
000EB2  784980     MOV.B W0, [W3]
000EB4  784981     MOV.B W1, [W3]
000EB6  784982     MOV.B W2, [W3]
271:                   // 2. Configure Output Functions
272:                   // Assign U2TX output function to pin RP17
273:                   RPOR8bits.RP17R = 5;
000EB8  803F21     MOV RPOR8, W1
000EBA  280FF0     MOV #0x80FF, W0
000EBC  608080     AND W1, W0, W1
000EBE  205000     MOV #0x500, W0
000EC0  700001     IOR W0, W1, W0
000EC2  883F20     MOV W0, RPOR8
274:                   // Assign OC1 output function to pin RP11
275:                   RPOR5bits.RP11R = 13;
000EC4  803EF1     MOV RPOR5, W1
000EC6  280FF0     MOV #0x80FF, W0
000EC8  608080     AND W1, W0, W1
000ECA  20D000     MOV #0xD00, W0
000ECC  700001     IOR W0, W1, W0
000ECE  883EF0     MOV W0, RPOR5
276:                   // 3. Configure Input Functions
277:                   // Assign pin RP10 to U2RX input function
278:                   RPINR19bits.U2RXR = 10;
000ED0  803DB1     MOV RPINR19, W1
000ED2  2FFC00     MOV #0xFFC0, W0
000ED4  608000     AND W1, W0, W0
000ED6  B300A0     IOR #0xA, W0
000ED8  883DB0     MOV W0, RPINR19
279:                   // 4 Lock the PPS registers
280:                   __builtin_write_OSCCONL(OSCCON | 0x40);    
000EDA  800800     MOV OSCCON, W0
000EDC  780100     MOV W0, W2
000EDE  A06002     BSET W2, #6
000EE0  200460     MOV #0x46, W0
000EE2  200571     MOV #0x57, W1
000EE4  201003     MOV #0x100, W3
000EE6  784980     MOV.B W0, [W3]
000EE8  784981     MOV.B W1, [W3]
000EEA  784982     MOV.B W2, [W3]
281:                   
282:               #elif defined(PIC32MZ1024EFH064_BH)
283:                   
284:                   // Set up PPS (I/O Pin-Mapping) for all I/O in this application
285:                   // U2RX <-- RPB15   (DEBUG PORT PC-TX pin)
286:                   // U2TX --> RPB14   (DEBUG PORT PC-RX pin)
287:                   
288:                   // U2RX pin (RPB15) is an ADC input, so need to configure ANSEL register to
289:                   // disable analog pin function
290:                   ANSELBbits.ANSB15 = 0;
291:                   
292:                   // PPS unlock sequence
293:                   SYSKEY = 0x0;         
294:                   SYSKEY = 0xAA996655;         
295:                   SYSKEY = 0x556699AA; 
296:                   CFGCONbits.IOLOCK = 0;  // unlock PPS registers for writing
297:                   
298:                   // modify the PPS registers for the application (per table 11-2 in data sheet)
299:                   U2RXRbits.U2RXR = 3;        // Map RPB15 to U2RX
300:                   RPB14Rbits.RPB14R = 2;      // Map U2TX to RPB14
301:                   
302:                   // PPS re-lock sequence
303:                   CFGCONbits.IOLOCK = 1;         
304:                   SYSKEY = 0x0;    
305:                   
306:               #endif
307:               }
000EEC  FA8000     ULNK
000EEE  060000     RETURN
308:               
309:               void UartConfig(void){
000EF0  FA0000     LNK #0x0
310:               
311:               #if defined(PIC16F19197_BH)
312:                   
313:                   // Initialize UART1 for use as the DEBUG PORT for printf() messages
314:                   
315:                   // Turn the UART off
316:                   RC1STAbits.SPEN = 0;
317:                   TX1STAbits.TXEN = 0;
318:               
319:                   // Disable U1 Interrupts
320:                   PIR3bits.TX1IF = 0;                                                         // Clear the Transmit Interrupt Flag
321:                   PIE3bits.TX1IE = 0;                                                         // Disable Transmit Interrupts
322:                   PIR3bits.RC1IF = 0;                                                         // Clear the Receive Interrupt Flag
323:                   PIE3bits.RC1IE = 0;                                                         // Disable Receive Interrupts
324:                   
325:                   // Configure TX Channel
326:                   TX1STAbits.SYNC = 0;                                                        // Async mode
327:                   TX1STAbits.BRGH = 1;                                                        // High speed BRG
328:                   
329:                   // Configure RX Channel
330:                   RC1STAbits.CREN = 1;                                                        // Enable continuous RX
331:                   
332:                   // Configure BRG (BRGH = 1, BRG = 1)
333:                   BAUD1CONbits.BRG16 = 1;
334:                   SP1BRGH = 0x00;
335:                   SP1BRGL = 0x44;               // decimal 68 (115200 baud)
336:                   
337:                   // ...And turn the UART on
338:                   RC1STAbits.SPEN = 1;
339:                   TX1STAbits.TXEN = 1;    
340:                   
341:               #elif defined(PIC24FJ1024GA606_BH)
342:                   
343:                   // Initialize UART2 for use as the DEBUG PORT for printf() messages
344:                   
345:                   __C30_UART = 2;         // MACRO: Divert printf() output to UART 2 - see XC16 manual
000EF2  200020     MOV #0x2, W0
000EF4  884530     MOV W0, 0x8A6
346:                   
347:                   U2MODEbits.UARTEN = 0;  // Disable UART  
000EF6  A9E3AF     BCLR 0x3AF, #7
348:                   U2STAbits.UTXEN = 0;
000EF8  A943B1     BCLR 0x3B1, #2
349:                   U2MODEbits.BRGH = 1;    // Enable high rate baud clock
000EFA  A863AE     BSET U2MODE, #3
350:                   U2BRG = 16;             // Baud Rate generator set to 115200 baud
000EFC  200100     MOV #0x10, W0
000EFE  881DB0     MOV W0, U2BRG
351:                   U2MODEbits.UARTEN = 1;
000F00  A8E3AF     BSET 0x3AF, #7
352:                   U2STAbits.UTXEN = 1;    // Enable UART    
000F02  A843B1     BSET 0x3B1, #2
353:                   
354:               #elif defined(PIC32MZ1024EFH064_BH)
355:                   
356:                   // Initialize UART2 for use as the DEBUG PORT for printf() messages
357:                   
358:                   // Note: No special initialization is required for printf()
359:                   // printf() uses UART 2 for output by default as long as UART 2 is initialized before use
360:                   
361:                   U2MODEbits.UARTEN = 0;  // Disable UART  
362:                   U2STAbits.UTXEN = 0;
363:                   U2MODEbits.BRGH = 1;    // Enable high rate baud clock
364:                   U2BRG = 16;             // Baud Rate generator set to 115200 baud
365:                   U2MODEbits.UARTEN = 1;
366:                   U2STAbits.UTXEN = 1;    // Enable UART    
367:                   
368:               #endif
369:                   
370:               }
000F04  FA8000     ULNK
000F06  060000     RETURN
371:               
372:               #if defined(PIC16F19197_BH)
373:                   
374:               // XC8 Stub required to redirect printf() statements to UART 1
375:               
376:               void putch(char c) {
377:                   while(!TX1STAbits.TRMT);   // wait while Tx buffer full
378:                   TX1REG = c;
379:               }
380:               
381:               #endif
382:               
383:               void PWMConfig(void){
000F08  FA0000     LNK #0x0
384:                   
385:               #if defined(PIC16F19197_BH)
386:                   
387:                   T2CONbits.T2ON = 0;         // turn Timer2 off
388:                   T2TMR = 0;                  // reset the count   
389:                   T2CLKCONbits.CS = 1;        // Select Fcyc (8 MHz) as clock source
390:                   T2CONbits.T2CKPS = 5;       // 1:32 prescale (250 kHz)
391:                   T2PR = 250;                 // set the PWM period value for 1000 uS (1mS)
392:                   
393:                   CCP1CONbits.EN = 0;         // turn CCP1 off
394:                   CCP1CONbits.MODE = 15;      // set CCP1 mode to PWM
395:                   CCPR1H = 0x01;
396:                   CCPR1L = 0xF4;              // set up 50% duty cycle on output (count = 500)
397:                   CCP1CONbits.EN = 1;         // turn CCP1 on
398:                   
399:                   PIR4bits.TMR2IF = 0;
400:                   PIE4bits.TMR2IE = 1;        // enable Timer2 interrupt on start of PWM cycle
401:                   T2CONbits.T2ON = 1;         // turn Timer2 on
402:               
403:               #elif defined(PIC24FJ1024GA606_BH)
404:                
405:                   T2CONbits.TON = 0;          // turn Timer2 off
000F0A  A9E1A1     BCLR 0x1A1, #7
406:                   TMR2 = 0x00;                // reset the count
000F0C  EF2196     CLR TMR2
407:                   T2CONbits.TCS = 0;          // Select Fcyc (8 MHz) as clock source
000F0E  A921A0     BCLR T2CON, #1
408:                   T2CONbits.TCKPS = 1;        // 1:8 prescale (1 MHz)
000F10  800D01     MOV T2CON, W1
000F12  2FFCF0     MOV #0xFFCF, W0
000F14  608000     AND W1, W0, W0
000F16  A04000     BSET W0, #4
000F18  880D00     MOV W0, T2CON
409:                   PR2 = 1000;                 // set the PWM period value for 1000 uS (1mS)
000F1A  203E80     MOV #0x3E8, W0
000F1C  880CE0     MOV W0, PR2
410:                   
411:                   OC1CON1bits.OCM = 0;        // turn OC1 off
000F1E  801181     MOV OC1CON1, W1
000F20  2FFF80     MOV #0xFFF8, W0
000F22  608000     AND W1, W0, W0
000F24  881180     MOV W0, OC1CON1
412:                   OC1R = 500;                 // set up 50% duty cycle on output (count = 500)
000F26  201F40     MOV #0x1F4, W0
000F28  8811B0     MOV W0, OC1R
413:                   OC1CON1bits.OCTSEL = 0;     // select Timer 2 as the OC time base
000F2A  801181     MOV OC1CON1, W1
000F2C  2E3FF0     MOV #0xE3FF, W0
000F2E  608000     AND W1, W0, W0
000F30  881180     MOV W0, OC1CON1
414:                   OC1CON1bits.OCM = 0b110;    // set OC1 mode to PWM (Edge PWM)
000F32  801181     MOV OC1CON1, W1
000F34  2FFF80     MOV #0xFFF8, W0
000F36  608000     AND W1, W0, W0
000F38  B30060     IOR #0x6, W0
000F3A  881180     MOV W0, OC1CON1
415:                   
416:                   IFS0bits.T2IF = 0;          // clear Timer 2 interrupt flag
000F3C  A9E088     BCLR IFS0, #7
417:                   //IEC0bits.T2IE = 1;          // enable Timer 2 interrupts
418:                   IFS0bits.OC1IF = 0;
000F3E  A94088     BCLR IFS0, #2
419:                   IEC0bits.OC1IE = 1;
000F40  A84098     BSET IEC0, #2
420:                   T2CONbits.TON = 1;          // start timer (starts PWMs)
000F42  A8E1A1     BSET 0x1A1, #7
421:                   
422:               #endif    
423:                   
424:               }
000F44  FA8000     ULNK
000F46  060000     RETURN
425:               
426:               // 1 kHz ISR (generated on rising edge of PWM signal) to toggle USER LED
427:               
428:               #if defined(PIC16F19197_BH)
429:               
430:               void __interrupt() interruptHandler(void)
431:               {
432:                   LATEbits.LATE5 ^= 1;
433:                   PIR4bits.TMR2IF = 0;
434:               }
435:               
436:               #elif defined(PIC24FJ1024GA606_BH)
437:               
438:               void __attribute__((interrupt, no_auto_psv)) _OC1Interrupt(void)
439:               {
000214  BE9F80     MOV.D W0, [W15++]
000216  FA0000     LNK #0x0
440:                   LATEbits.LATE2 ^= 1;
000218  8035B0     MOV LATE, W0
00021A  DE0042     LSR W0, #2, W0
00021C  604061     AND.B W0, #0x1, W0
00021E  A20400     BTG.B W0, #0
000220  604061     AND.B W0, #0x1, W0
000222  FB8000     ZE W0, W0
000224  600061     AND W0, #0x1, W0
000226  DD0042     SL W0, #2, W0
000228  8035B1     MOV LATE, W1
00022A  A12001     BCLR W1, #2
00022C  700001     IOR W0, W1, W0
00022E  8835B0     MOV W0, LATE
441:                   IFS0bits.OC1IF = 0;
000230  A94088     BCLR IFS0, #2
442:               }
000232  FA8000     ULNK
000234  BE004F     MOV.D [--W15], W0
000236  064000     RETFIE
443:               
444:               #endif
445:               
446:               
447:               
448:               
